{
	"_fullName": "core/geom/SPMat4.h",
	"_kind": "file",
	"_name": "core/geom/SPMat4.h",
	"childs": [{
		"_fullName": "SPVec2.h",
		"_kind": "include directive",
		"_name": "SPVec2.h",
		"id": 288057728,
		"include": "core/geom/SPVec2.h",
		"include_kind": "local",
		"kind": "include directive",
		"name": "SPVec2.h"
	}, {
		"_fullName": "SPVec3.h",
		"_kind": "include directive",
		"_name": "SPVec3.h",
		"id": 548825706,
		"include": "core/geom/SPVec3.h",
		"include_kind": "local",
		"kind": "include directive",
		"name": "SPVec3.h"
	}, {
		"_fullName": "SPVec4.h",
		"_kind": "include directive",
		"_name": "SPVec4.h",
		"id": 2412415796,
		"include": "core/geom/SPVec4.h",
		"include_kind": "local",
		"kind": "include directive",
		"name": "SPVec4.h"
	}, {
		"_fullName": "STAPPLER_GEOM_SPMAT4_H_",
		"_kind": "macro definition",
		"_name": "STAPPLER_GEOM_SPMAT4_H_",
		"id": 4178105251,
		"is_function_like": false,
		"is_object_like": true,
		"is_variadic": false,
		"kind": "macro definition",
		"name": "STAPPLER_GEOM_SPMAT4_H_",
		"replacement": ""
	}, {
		"_fullName": "::stappler",
		"_kind": "namespace",
		"_name": "stappler",
		"childs": [{
			"_fullName": "::stappler::geom",
			"_kind": "namespace",
			"_name": "geom",
			"childs": [{
				"_fullName": "::stappler::geom::Mat4",
				"_kind": "class",
				"_name": "Mat4",
				"attributes": [{
					"arguments": [{
						"kind": "int_literal",
						"spelling": "16"
					}],
					"is_variadic": false,
					"kind": "alignas_",
					"name": "alignas"
				}],
				"childs":  [{
					"_fullName": "public",
					"_kind": "access specifier",
					"_name": "public",
					"access_specifier": "public",
					"id": 893076784,
					"kind": "access specifier",
					"name": "public"
				}, {
					"_fullName": "::stappler::geom::Mat4::createLookAt(stappler::geom::Vec3 const&,stappler::geom::Vec3 const&,stappler::geom::Vec3 const&,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "createLookAt",
					"body_kind": "declaration",
					"id": 3319327932,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"kind": "function",
					"name": "createLookAt",
					"parameters": [{
						"_fullName": "eyePosition",
						"_kind": "function parameter",
						"_name": "eyePosition",
						"id": 1013359271,
						"kind": "function parameter",
						"name": "eyePosition",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "targetPosition",
						"_kind": "function parameter",
						"_name": "targetPosition",
						"id": 1399760021,
						"kind": "function parameter",
						"name": "targetPosition",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "up",
						"_kind": "function parameter",
						"_name": "up",
						"id": 759082068,
						"kind": "function parameter",
						"name": "up",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3 const&,stappler::geom::Vec3 const&,stappler::geom::Vec3 const&,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::createLookAt(float,float,float,float,float,float,float,float,float,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "createLookAt",
					"body_kind": "declaration",
					"id": 2318424061,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"kind": "function",
					"name": "createLookAt",
					"parameters": [{
						"_fullName": "eyePositionX",
						"_kind": "function parameter",
						"_name": "eyePositionX",
						"id": 3512137422,
						"kind": "function parameter",
						"name": "eyePositionX",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "eyePositionY",
						"_kind": "function parameter",
						"_name": "eyePositionY",
						"id": 279208051,
						"kind": "function parameter",
						"name": "eyePositionY",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "eyePositionZ",
						"_kind": "function parameter",
						"_name": "eyePositionZ",
						"id": 3272698385,
						"kind": "function parameter",
						"name": "eyePositionZ",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "targetCenterX",
						"_kind": "function parameter",
						"_name": "targetCenterX",
						"id": 2145711852,
						"kind": "function parameter",
						"name": "targetCenterX",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "targetCenterY",
						"_kind": "function parameter",
						"_name": "targetCenterY",
						"id": 1396405998,
						"kind": "function parameter",
						"name": "targetCenterY",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "targetCenterZ",
						"_kind": "function parameter",
						"_name": "targetCenterZ",
						"id": 1659044196,
						"kind": "function parameter",
						"name": "targetCenterZ",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "upX",
						"_kind": "function parameter",
						"_name": "upX",
						"id": 2294248319,
						"kind": "function parameter",
						"name": "upX",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "upY",
						"_kind": "function parameter",
						"_name": "upY",
						"id": 377819521,
						"kind": "function parameter",
						"name": "upY",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "upZ",
						"_kind": "function parameter",
						"_name": "upZ",
						"id": 2961495391,
						"kind": "function parameter",
						"name": "upZ",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,float,float,float,float,float,float,float,float,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::createPerspective(float,float,float,float,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "createPerspective",
					"body_kind": "declaration",
					"comment": "Builds a perspective projection matrix based on a field of view and returns by value.\n\nProjection space refers to the space after applying projection transformation from view space.\nAfter the projection transformation, visible content has x- and y-coordinates ranging from -1 to 1,\nand a z-coordinate ranging from 0 to 1. To obtain the viewable area (in world space) of a scene,\ncreate a BoundingFrustum and pass the combined view and projection matrix to the constructor.",
					"id": 1428157992,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"kind": "function",
					"name": "createPerspective",
					"parameters": [{
						"_fullName": "fieldOfView",
						"_kind": "function parameter",
						"_name": "fieldOfView",
						"id": 1046951248,
						"kind": "function parameter",
						"name": "fieldOfView",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "aspectRatio",
						"_kind": "function parameter",
						"_name": "aspectRatio",
						"id": 1022579368,
						"kind": "function parameter",
						"name": "aspectRatio",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "zNearPlane",
						"_kind": "function parameter",
						"_name": "zNearPlane",
						"id": 3919365107,
						"kind": "function parameter",
						"name": "zNearPlane",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "zFarPlane",
						"_kind": "function parameter",
						"_name": "zFarPlane",
						"id": 139584717,
						"kind": "function parameter",
						"name": "zFarPlane",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,float,float,float,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::createOrthographic(float,float,float,float,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "createOrthographic",
					"body_kind": "declaration",
					"comment": "Creates an orthographic projection matrix.",
					"id": 1970369789,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"kind": "function",
					"name": "createOrthographic",
					"parameters": [{
						"_fullName": "width",
						"_kind": "function parameter",
						"_name": "width",
						"id": 2103112543,
						"kind": "function parameter",
						"name": "width",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "height",
						"_kind": "function parameter",
						"_name": "height",
						"id": 2211349819,
						"kind": "function parameter",
						"name": "height",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "zNearPlane",
						"_kind": "function parameter",
						"_name": "zNearPlane",
						"id": 3919365107,
						"kind": "function parameter",
						"name": "zNearPlane",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "zFarPlane",
						"_kind": "function parameter",
						"_name": "zFarPlane",
						"id": 139584717,
						"kind": "function parameter",
						"name": "zFarPlane",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,float,float,float,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::createOrthographicOffCenter(float,float,float,float,float,float,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "createOrthographicOffCenter",
					"body_kind": "declaration",
					"comment": "Creates an orthographic projection matrix.\n\nProjection space refers to the space after applying\nprojection transformation from view space. After the\nprojection transformation, visible content has\nx and y coordinates ranging from -1 to 1, and z coordinates\nranging from 0 to 1.\n\nUnlike perspective projection, in orthographic projection\nthere is no perspective foreshortening.\n\nThe viewable area of this orthographic projection extends\nfrom left to right on the x-axis, bottom to top on the y-axis,\nand zNearPlane to zFarPlane on the z-axis. These values are\nrelative to the position and x, y, and z-axes of the view.\nTo obtain the viewable area (in world space) of a scene,\ncreate a BoundingFrustum and pass the combined view and\nprojection matrix to the constructor.",
					"id": 2815952978,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"kind": "function",
					"name": "createOrthographicOffCenter",
					"parameters": [{
						"_fullName": "left",
						"_kind": "function parameter",
						"_name": "left",
						"id": 196403651,
						"kind": "function parameter",
						"name": "left",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "right",
						"_kind": "function parameter",
						"_name": "right",
						"id": 3270037782,
						"kind": "function parameter",
						"name": "right",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "bottom",
						"_kind": "function parameter",
						"_name": "bottom",
						"id": 1814608365,
						"kind": "function parameter",
						"name": "bottom",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "top",
						"_kind": "function parameter",
						"_name": "top",
						"id": 128394223,
						"kind": "function parameter",
						"name": "top",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "zNearPlane",
						"_kind": "function parameter",
						"_name": "zNearPlane",
						"id": 3919365107,
						"kind": "function parameter",
						"name": "zNearPlane",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "zFarPlane",
						"_kind": "function parameter",
						"_name": "zFarPlane",
						"id": 139584717,
						"kind": "function parameter",
						"name": "zFarPlane",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,float,float,float,float,float,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::createBillboard(stappler::geom::Vec3 const&,stappler::geom::Vec3 const&,stappler::geom::Vec3 const&,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "createBillboard",
					"body_kind": "declaration",
					"comment": "Creates a spherical billboard that rotates around a specified object position.\n\nThis method computes the facing direction of the billboard from the object position\nand camera position. When the object and camera positions are too close, the matrix\nwill not be accurate. To avoid this problem, this method defaults to the identity\nrotation if the positions are too close. (See the other overload of createBillboard\nfor an alternative approach).",
					"id": 1177484871,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"kind": "function",
					"name": "createBillboard",
					"parameters": [{
						"_fullName": "objectPosition",
						"_kind": "function parameter",
						"_name": "objectPosition",
						"id": 2543255206,
						"kind": "function parameter",
						"name": "objectPosition",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "cameraPosition",
						"_kind": "function parameter",
						"_name": "cameraPosition",
						"id": 2104378725,
						"kind": "function parameter",
						"name": "cameraPosition",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "cameraUpVector",
						"_kind": "function parameter",
						"_name": "cameraUpVector",
						"id": 3679852810,
						"kind": "function parameter",
						"name": "cameraUpVector",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3 const&,stappler::geom::Vec3 const&,stappler::geom::Vec3 const&,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::createBillboard(stappler::geom::Vec3 const&,stappler::geom::Vec3 const&,stappler::geom::Vec3 const&,stappler::geom::Vec3 const&,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "createBillboard",
					"body_kind": "declaration",
					"comment": "Creates a spherical billboard that rotates around a specified object position with\nprovision for a safe default orientation.\n\nThis method computes the facing direction of the billboard from the object position\nand camera position. When the object and camera positions are too close, the matrix\nwill not be accurate. To avoid this problem, this method uses the specified camera\nforward vector if the positions are too close. (See the other overload of createBillboard\nfor an alternative approach).",
					"id": 2398161593,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"kind": "function",
					"name": "createBillboard",
					"parameters": [{
						"_fullName": "objectPosition",
						"_kind": "function parameter",
						"_name": "objectPosition",
						"id": 2543255206,
						"kind": "function parameter",
						"name": "objectPosition",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "cameraPosition",
						"_kind": "function parameter",
						"_name": "cameraPosition",
						"id": 2104378725,
						"kind": "function parameter",
						"name": "cameraPosition",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "cameraUpVector",
						"_kind": "function parameter",
						"_name": "cameraUpVector",
						"id": 3679852810,
						"kind": "function parameter",
						"name": "cameraUpVector",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "cameraForwardVector",
						"_kind": "function parameter",
						"_name": "cameraForwardVector",
						"id": 1568710737,
						"kind": "function parameter",
						"name": "cameraForwardVector",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3 const&,stappler::geom::Vec3 const&,stappler::geom::Vec3 const&,stappler::geom::Vec3 const&,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::createScale(stappler::geom::Vec3 const&,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "createScale",
					"body_kind": "declaration",
					"id": 1514738536,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"kind": "function",
					"name": "createScale",
					"parameters": [{
						"_fullName": "scale",
						"_kind": "function parameter",
						"_name": "scale",
						"id": 4279669230,
						"kind": "function parameter",
						"name": "scale",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3 const&,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::createScale(float,float,float,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "createScale",
					"body_kind": "declaration",
					"id": 3656671831,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"kind": "function",
					"name": "createScale",
					"parameters": [{
						"_fullName": "xScale",
						"_kind": "function parameter",
						"_name": "xScale",
						"id": 1067724672,
						"kind": "function parameter",
						"name": "xScale",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "yScale",
						"_kind": "function parameter",
						"_name": "yScale",
						"id": 2643966016,
						"kind": "function parameter",
						"name": "yScale",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "zScale",
						"_kind": "function parameter",
						"_name": "zScale",
						"id": 2429227741,
						"kind": "function parameter",
						"name": "zScale",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,float,float,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::createRotation(stappler::geom::Quaternion const&,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "createRotation",
					"body_kind": "declaration",
					"id": 1838756724,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"kind": "function",
					"name": "createRotation",
					"parameters": [{
						"_fullName": "quat",
						"_kind": "function parameter",
						"_name": "quat",
						"id": 3345887904,
						"kind": "function parameter",
						"name": "quat",
						"type": {
							"_typeName": "stappler::geom::Quaternion const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Quaternion const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Quaternion",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Quaternion",
										"objects": [{
											"_fullName": "::stappler::geom::Quaternion",
											"_kind": "class",
											"_name": "Quaternion",
											"class_kind": "class",
											"comment": "\nDefines a 4-element quaternion that represents the orientation of an object in space.\n\nQuaternions are typically used as a replacement for euler angles and rotation matrices\nas a way to achieve smooth interpolation and avoid gimbal lock.\n\nNote that this quaternion class does not automatically keep the quaternion normalized.\nTherefore, care must be taken to normalize the quaternion when necessary, by calling\nthe normalize method.\nThis class provides three methods for doing quaternion interpolation: lerp, slerp, and squad.\n\nlerp (linear interpolation): the interpolation curve gives a straight line in quaternion\nspace. It is simple and fast to compute. The only problem is that it does not provide\nconstant angular velocity. Note that a constant velocity is not necessarily a requirement\nfor a curve;\nslerp (spherical linear interpolation): the interpolation curve forms a great arc on the\nquaternion unit sphere. Slerp provides constant angular velocity;\nsquad (spherical spline interpolation): interpolating between a series of rotations using\nslerp leads to the following problems:\n- the curve is not smooth at the control points;\n- the angular velocity is not constant;\n- the angular velocity is not continuous at the control points.\n\nSince squad is continuously differentiable, it remedies the first and third problems\nmentioned above.\nThe slerp method provided here is intended for interpolation of principal rotations.\nIt treats +q and -q as the same principal rotation and is at liberty to use the negative\nof either input. The resulting path is always the shorter arc.\n\nThe lerp method provided here interpolates strictly in quaternion space. Note that the\nresulting path may pass through the origin if interpolating between a quaternion and its\nexact negative.\n\nAs an example, consider the following quaternions:\n\nq1 = (0.6, 0.8, 0.0, 0.0),\nq2 = (0.0, 0.6, 0.8, 0.0),\nq3 = (0.6, 0.0, 0.8, 0.0), and\nq4 = (-0.8, 0.0, -0.6, 0.0).\nFor the point p = (1.0, 1.0, 1.0), the following figures show the trajectories of p\nusing lerp, slerp, and squad.\n",
											"id": 289528640,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Quaternion",
											"scope": {
												"name": "Quaternion"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Quaternion const&,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::createRotation(stappler::geom::Vec3 const&,float,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "createRotation",
					"body_kind": "declaration",
					"id": 1283635463,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"kind": "function",
					"name": "createRotation",
					"parameters": [{
						"_fullName": "axis",
						"_kind": "function parameter",
						"_name": "axis",
						"id": 2450752328,
						"kind": "function parameter",
						"name": "axis",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "angle",
						"_kind": "function parameter",
						"_name": "angle",
						"id": 2170067527,
						"kind": "function parameter",
						"name": "angle",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3 const&,float,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::createRotationX(float,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "createRotationX",
					"body_kind": "declaration",
					"id": 1205278044,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"kind": "function",
					"name": "createRotationX",
					"parameters": [{
						"_fullName": "angle",
						"_kind": "function parameter",
						"_name": "angle",
						"id": 2170067527,
						"kind": "function parameter",
						"name": "angle",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::createRotationY(float,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "createRotationY",
					"body_kind": "declaration",
					"id": 1262325279,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"kind": "function",
					"name": "createRotationY",
					"parameters": [{
						"_fullName": "angle",
						"_kind": "function parameter",
						"_name": "angle",
						"id": 2170067527,
						"kind": "function parameter",
						"name": "angle",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::createRotationZ(float,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "createRotationZ",
					"body_kind": "declaration",
					"id": 1577646541,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"kind": "function",
					"name": "createRotationZ",
					"parameters": [{
						"_fullName": "angle",
						"_kind": "function parameter",
						"_name": "angle",
						"id": 2170067527,
						"kind": "function parameter",
						"name": "angle",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::createTranslation(stappler::geom::Vec3 const&,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "createTranslation",
					"body_kind": "declaration",
					"id": 2826417113,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"kind": "function",
					"name": "createTranslation",
					"parameters": [{
						"_fullName": "translation",
						"_kind": "function parameter",
						"_name": "translation",
						"id": 2035964458,
						"kind": "function parameter",
						"name": "translation",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3 const&,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::createTranslation(float,float,float,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "createTranslation",
					"body_kind": "declaration",
					"id": 2929658597,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"kind": "function",
					"name": "createTranslation",
					"parameters": [{
						"_fullName": "xTranslation",
						"_kind": "function parameter",
						"_name": "xTranslation",
						"id": 2033250754,
						"kind": "function parameter",
						"name": "xTranslation",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "yTranslation",
						"_kind": "function parameter",
						"_name": "yTranslation",
						"id": 3340243295,
						"kind": "function parameter",
						"name": "yTranslation",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "zTranslation",
						"_kind": "function parameter",
						"_name": "zTranslation",
						"id": 636254035,
						"kind": "function parameter",
						"name": "zTranslation",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,float,float,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::add(stappler::geom::Mat4 const&,stappler::geom::Mat4 const&,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "add",
					"body_kind": "definition",
					"id": 1295633849,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"kind": "function",
					"name": "add",
					"parameters": [{
						"_fullName": "m1",
						"_kind": "function parameter",
						"_name": "m1",
						"id": 205583190,
						"kind": "function parameter",
						"name": "m1",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "m2",
						"_kind": "function parameter",
						"_name": "m2",
						"id": 610410811,
						"kind": "function parameter",
						"name": "m2",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Mat4 const&,stappler::geom::Mat4 const&,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::multiply(stappler::geom::Mat4 const&,float,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "multiply",
					"body_kind": "definition",
					"id": 1646836168,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"kind": "function",
					"name": "multiply",
					"parameters": [{
						"_fullName": "mat",
						"_kind": "function parameter",
						"_name": "mat",
						"id": 247568213,
						"kind": "function parameter",
						"name": "mat",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "scalar",
						"_kind": "function parameter",
						"_name": "scalar",
						"id": 3137648071,
						"kind": "function parameter",
						"name": "scalar",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Mat4 const&,float,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::multiply(stappler::geom::Mat4 const&,stappler::geom::Mat4 const&,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "multiply",
					"body_kind": "definition",
					"id": 3141905538,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"kind": "function",
					"name": "multiply",
					"parameters": [{
						"_fullName": "m1",
						"_kind": "function parameter",
						"_name": "m1",
						"id": 205583190,
						"kind": "function parameter",
						"name": "m1",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "m2",
						"_kind": "function parameter",
						"_name": "m2",
						"id": 610410811,
						"kind": "function parameter",
						"name": "m2",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Mat4 const&,stappler::geom::Mat4 const&,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::subtract(stappler::geom::Mat4 const&,stappler::geom::Mat4 const&,stappler::geom::Mat4*)",
					"_kind": "function",
					"_name": "subtract",
					"body_kind": "definition",
					"id": 659305383,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"kind": "function",
					"name": "subtract",
					"parameters": [{
						"_fullName": "m1",
						"_kind": "function parameter",
						"_name": "m1",
						"id": 205583190,
						"kind": "function parameter",
						"name": "m1",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "m2",
						"_kind": "function parameter",
						"_name": "m2",
						"id": 610410811,
						"kind": "function parameter",
						"name": "m2",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"return_type":  {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Mat4 const&,stappler::geom::Mat4 const&,stappler::geom::Mat4*)",
					"storage_class": [
						"static"
					]
				}, {
					"_fullName": "::stappler::geom::Mat4::m",
					"_kind": "member variable",
					"_name": "m",
					"id": 1584242000,
					"is_mutable": false,
					"kind": "member variable",
					"name": "m",
					"type": {
						"_typeName": "float[16]",
						"kind": "array",
						"size": {
							"kind": "literal",
							"type": {
								"_typeName": "unsigned long long",
								"builtin_type_kind": "unsigned long long",
								"kind": "builtin"
							},
							"value": "16"
						},
						"value_type":  {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}
				}, {
					"_fullName": "::stappler::geom::Mat4::Mat4()",
					"_kind": "constructor",
					"_name": "Mat4",
					"body_kind": "definition",
					"id": 4284136620,
					"is_consteval": false,
					"is_constexpr": true,
					"is_declaration": false,
					"is_definition": true,
					"is_explicit": false,
					"is_variadic": false,
					"kind": "constructor",
					"name": "Mat4",
					"semantic_scope": "",
					"signature": "()"
				}, {
					"_fullName": "::stappler::geom::Mat4::Mat4(float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float)",
					"_kind": "constructor",
					"_name": "Mat4",
					"body_kind": "definition",
					"id": 3007682565,
					"is_consteval": false,
					"is_constexpr": true,
					"is_declaration": false,
					"is_definition": true,
					"is_explicit": false,
					"is_variadic": false,
					"kind": "constructor",
					"name": "Mat4",
					"parameters": [{
						"_fullName": "m11",
						"_kind": "function parameter",
						"_name": "m11",
						"id": 4175895060,
						"kind": "function parameter",
						"name": "m11",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "m12",
						"_kind": "function parameter",
						"_name": "m12",
						"id": 2279677885,
						"kind": "function parameter",
						"name": "m12",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "m13",
						"_kind": "function parameter",
						"_name": "m13",
						"id": 4026023232,
						"kind": "function parameter",
						"name": "m13",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "m14",
						"_kind": "function parameter",
						"_name": "m14",
						"id": 1074230685,
						"kind": "function parameter",
						"name": "m14",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "m21",
						"_kind": "function parameter",
						"_name": "m21",
						"id": 2394891207,
						"kind": "function parameter",
						"name": "m21",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "m22",
						"_kind": "function parameter",
						"_name": "m22",
						"id": 2851950462,
						"kind": "function parameter",
						"name": "m22",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "m23",
						"_kind": "function parameter",
						"_name": "m23",
						"id": 443314372,
						"kind": "function parameter",
						"name": "m23",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "m24",
						"_kind": "function parameter",
						"_name": "m24",
						"id": 3453924442,
						"kind": "function parameter",
						"name": "m24",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "m31",
						"_kind": "function parameter",
						"_name": "m31",
						"id": 4286398039,
						"kind": "function parameter",
						"name": "m31",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "m32",
						"_kind": "function parameter",
						"_name": "m32",
						"id": 2850705342,
						"kind": "function parameter",
						"name": "m32",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "m33",
						"_kind": "function parameter",
						"_name": "m33",
						"id": 3446227039,
						"kind": "function parameter",
						"name": "m33",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "m34",
						"_kind": "function parameter",
						"_name": "m34",
						"id": 796726623,
						"kind": "function parameter",
						"name": "m34",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "m41",
						"_kind": "function parameter",
						"_name": "m41",
						"id": 3108571724,
						"kind": "function parameter",
						"name": "m41",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "m42",
						"_kind": "function parameter",
						"_name": "m42",
						"id": 778465402,
						"kind": "function parameter",
						"name": "m42",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "m43",
						"_kind": "function parameter",
						"_name": "m43",
						"id": 1819491871,
						"kind": "function parameter",
						"name": "m43",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "m44",
						"_kind": "function parameter",
						"_name": "m44",
						"id": 736557441,
						"kind": "function parameter",
						"name": "m44",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}],
					"semantic_scope": "",
					"signature": "(float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float)"
				}, {
					"_fullName": "::stappler::geom::Mat4::Mat4(float,float,float,float,float,float)",
					"_kind": "constructor",
					"_name": "Mat4",
					"body_kind": "definition",
					"id": 744374824,
					"is_consteval": false,
					"is_constexpr": true,
					"is_declaration": false,
					"is_definition": true,
					"is_explicit": false,
					"is_variadic": false,
					"kind": "constructor",
					"name": "Mat4",
					"parameters": [{
						"_fullName": "a",
						"_kind": "function parameter",
						"_name": "a",
						"id": 1426945110,
						"kind": "function parameter",
						"name": "a",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "b",
						"_kind": "function parameter",
						"_name": "b",
						"id": 2718739903,
						"kind": "function parameter",
						"name": "b",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "c",
						"_kind": "function parameter",
						"_name": "c",
						"id": 4004515611,
						"kind": "function parameter",
						"name": "c",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "d",
						"_kind": "function parameter",
						"_name": "d",
						"id": 1123242640,
						"kind": "function parameter",
						"name": "d",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "e",
						"_kind": "function parameter",
						"_name": "e",
						"id": 4183478727,
						"kind": "function parameter",
						"name": "e",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "f",
						"_kind": "function parameter",
						"_name": "f",
						"id": 1729662580,
						"kind": "function parameter",
						"name": "f",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}],
					"semantic_scope": "",
					"signature": "(float,float,float,float,float,float)"
				}, {
					"_fullName": "::stappler::geom::Mat4::Mat4(stappler::geom::Mat4 const&)",
					"_kind": "constructor",
					"_name": "Mat4",
					"body_kind": "defaulted",
					"id": 3517063543,
					"is_consteval": false,
					"is_constexpr": true,
					"is_declaration": false,
					"is_definition": true,
					"is_explicit": false,
					"is_variadic": false,
					"kind": "constructor",
					"name": "Mat4",
					"parameters": [{
						"_fullName": "copy",
						"_kind": "function parameter",
						"_name": "copy",
						"id": 90569301,
						"kind": "function parameter",
						"name": "copy",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}],
					"semantic_scope": "",
					"signature": "(stappler::geom::Mat4 const&)"
				}, {
					"_fullName": "::stappler::geom::Mat4::add(float)",
					"_kind": "member function",
					"_name": "add",
					"body_kind": "definition",
					"cv_qualifier": "none",
					"id": 1109258132,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "add",
					"parameters": [{
						"_fullName": "scalar",
						"_kind": "function parameter",
						"_name": "scalar",
						"id": 3137648071,
						"kind": "function parameter",
						"name": "scalar",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float)"
				}, {
					"_fullName": "::stappler::geom::Mat4::add(float,stappler::geom::Mat4*)",
					"_kind": "member function",
					"_name": "add",
					"body_kind": "definition",
					"cv_qualifier": "none",
					"id": 1949970241,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "add",
					"parameters": [{
						"_fullName": "scalar",
						"_kind": "function parameter",
						"_name": "scalar",
						"id": 3137648071,
						"kind": "function parameter",
						"name": "scalar",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,stappler::geom::Mat4*)"
				}, {
					"_fullName": "::stappler::geom::Mat4::add(stappler::geom::Mat4 const&)",
					"_kind": "member function",
					"_name": "add",
					"body_kind": "definition",
					"cv_qualifier": "none",
					"id": 2077201472,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "add",
					"parameters": [{
						"_fullName": "mat",
						"_kind": "function parameter",
						"_name": "mat",
						"id": 247568213,
						"kind": "function parameter",
						"name": "mat",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Mat4 const&)"
				}, {
					"_fullName": "::stappler::geom::Mat4::decompose(stappler::geom::Vec3*,stappler::geom::Quaternion*,stappler::geom::Vec3*) const",
					"_kind": "member function",
					"_name": "decompose",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 1175275234,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "decompose",
					"parameters": [{
						"_fullName": "scale",
						"_kind": "function parameter",
						"_name": "scale",
						"id": 4279669230,
						"kind": "function parameter",
						"name": "scale",
						"type": {
							"_typeName": "stappler::geom::Vec3*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Vec3",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec3",
									"objects": [{
										"_fullName": "::stappler::geom::Vec3",
										"_kind": "class",
										"_name": "Vec3",
										"class_kind": "class",
										"id": 748569271,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec3",
										"scope": {
											"name": "Vec3"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}, {
						"_fullName": "rotation",
						"_kind": "function parameter",
						"_name": "rotation",
						"id": 1688882020,
						"kind": "function parameter",
						"name": "rotation",
						"type": {
							"_typeName": "stappler::geom::Quaternion*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Quaternion",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Quaternion",
									"objects": [{
										"_fullName": "::stappler::geom::Quaternion",
										"_kind": "class",
										"_name": "Quaternion",
										"class_kind": "class",
										"comment": "\nDefines a 4-element quaternion that represents the orientation of an object in space.\n\nQuaternions are typically used as a replacement for euler angles and rotation matrices\nas a way to achieve smooth interpolation and avoid gimbal lock.\n\nNote that this quaternion class does not automatically keep the quaternion normalized.\nTherefore, care must be taken to normalize the quaternion when necessary, by calling\nthe normalize method.\nThis class provides three methods for doing quaternion interpolation: lerp, slerp, and squad.\n\nlerp (linear interpolation): the interpolation curve gives a straight line in quaternion\nspace. It is simple and fast to compute. The only problem is that it does not provide\nconstant angular velocity. Note that a constant velocity is not necessarily a requirement\nfor a curve;\nslerp (spherical linear interpolation): the interpolation curve forms a great arc on the\nquaternion unit sphere. Slerp provides constant angular velocity;\nsquad (spherical spline interpolation): interpolating between a series of rotations using\nslerp leads to the following problems:\n- the curve is not smooth at the control points;\n- the angular velocity is not constant;\n- the angular velocity is not continuous at the control points.\n\nSince squad is continuously differentiable, it remedies the first and third problems\nmentioned above.\nThe slerp method provided here is intended for interpolation of principal rotations.\nIt treats +q and -q as the same principal rotation and is at liberty to use the negative\nof either input. The resulting path is always the shorter arc.\n\nThe lerp method provided here interpolates strictly in quaternion space. Note that the\nresulting path may pass through the origin if interpolating between a quaternion and its\nexact negative.\n\nAs an example, consider the following quaternions:\n\nq1 = (0.6, 0.8, 0.0, 0.0),\nq2 = (0.0, 0.6, 0.8, 0.0),\nq3 = (0.6, 0.0, 0.8, 0.0), and\nq4 = (-0.8, 0.0, -0.6, 0.0).\nFor the point p = (1.0, 1.0, 1.0), the following figures show the trajectories of p\nusing lerp, slerp, and squad.\n",
										"id": 289528640,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Quaternion",
										"scope": {
											"name": "Quaternion"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}, {
						"_fullName": "translation",
						"_kind": "function parameter",
						"_name": "translation",
						"id": 2035964458,
						"kind": "function parameter",
						"name": "translation",
						"type": {
							"_typeName": "stappler::geom::Vec3*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Vec3",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec3",
									"objects": [{
										"_fullName": "::stappler::geom::Vec3",
										"_kind": "class",
										"_name": "Vec3",
										"class_kind": "class",
										"id": 748569271,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec3",
										"scope": {
											"name": "Vec3"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "bool",
						"builtin_type_kind": "bool",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3*,stappler::geom::Quaternion*,stappler::geom::Vec3*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::decompose(float*,float*,float*) const",
					"_kind": "member function",
					"_name": "decompose",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 2839643339,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "decompose",
					"parameters": [{
						"_fullName": "scale",
						"_kind": "function parameter",
						"_name": "scale",
						"id": 4279669230,
						"kind": "function parameter",
						"name": "scale",
						"type": {
							"_typeName": "float*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "float",
								"builtin_type_kind": "float",
								"kind": "builtin"
							}
						}
					}, {
						"_fullName": "rotation",
						"_kind": "function parameter",
						"_name": "rotation",
						"id": 1688882020,
						"kind": "function parameter",
						"name": "rotation",
						"type": {
							"_typeName": "float*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "float",
								"builtin_type_kind": "float",
								"kind": "builtin"
							}
						}
					}, {
						"_fullName": "translation",
						"_kind": "function parameter",
						"_name": "translation",
						"id": 2035964458,
						"kind": "function parameter",
						"name": "translation",
						"type": {
							"_typeName": "float*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "float",
								"builtin_type_kind": "float",
								"kind": "builtin"
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "bool",
						"builtin_type_kind": "bool",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float*,float*,float*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::determinant() const",
					"_kind": "member function",
					"_name": "determinant",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 1939102732,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "determinant",
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "float",
						"builtin_type_kind": "float",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "() const"
				}, {
					"_fullName": "::stappler::geom::Mat4::getScale(stappler::geom::Vec3*) const",
					"_kind": "member function",
					"_name": "getScale",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 2316495392,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "getScale",
					"parameters": [{
						"_fullName": "scale",
						"_kind": "function parameter",
						"_name": "scale",
						"id": 4279669230,
						"kind": "function parameter",
						"name": "scale",
						"type": {
							"_typeName": "stappler::geom::Vec3*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Vec3",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec3",
									"objects": [{
										"_fullName": "::stappler::geom::Vec3",
										"_kind": "class",
										"_name": "Vec3",
										"class_kind": "class",
										"id": 748569271,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec3",
										"scope": {
											"name": "Vec3"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::getRotation(stappler::geom::Quaternion*) const",
					"_kind": "member function",
					"_name": "getRotation",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 1078033885,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "getRotation",
					"parameters": [{
						"_fullName": "rotation",
						"_kind": "function parameter",
						"_name": "rotation",
						"id": 1688882020,
						"kind": "function parameter",
						"name": "rotation",
						"type": {
							"_typeName": "stappler::geom::Quaternion*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Quaternion",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Quaternion",
									"objects": [{
										"_fullName": "::stappler::geom::Quaternion",
										"_kind": "class",
										"_name": "Quaternion",
										"class_kind": "class",
										"comment": "\nDefines a 4-element quaternion that represents the orientation of an object in space.\n\nQuaternions are typically used as a replacement for euler angles and rotation matrices\nas a way to achieve smooth interpolation and avoid gimbal lock.\n\nNote that this quaternion class does not automatically keep the quaternion normalized.\nTherefore, care must be taken to normalize the quaternion when necessary, by calling\nthe normalize method.\nThis class provides three methods for doing quaternion interpolation: lerp, slerp, and squad.\n\nlerp (linear interpolation): the interpolation curve gives a straight line in quaternion\nspace. It is simple and fast to compute. The only problem is that it does not provide\nconstant angular velocity. Note that a constant velocity is not necessarily a requirement\nfor a curve;\nslerp (spherical linear interpolation): the interpolation curve forms a great arc on the\nquaternion unit sphere. Slerp provides constant angular velocity;\nsquad (spherical spline interpolation): interpolating between a series of rotations using\nslerp leads to the following problems:\n- the curve is not smooth at the control points;\n- the angular velocity is not constant;\n- the angular velocity is not continuous at the control points.\n\nSince squad is continuously differentiable, it remedies the first and third problems\nmentioned above.\nThe slerp method provided here is intended for interpolation of principal rotations.\nIt treats +q and -q as the same principal rotation and is at liberty to use the negative\nof either input. The resulting path is always the shorter arc.\n\nThe lerp method provided here interpolates strictly in quaternion space. Note that the\nresulting path may pass through the origin if interpolating between a quaternion and its\nexact negative.\n\nAs an example, consider the following quaternions:\n\nq1 = (0.6, 0.8, 0.0, 0.0),\nq2 = (0.0, 0.6, 0.8, 0.0),\nq3 = (0.6, 0.0, 0.8, 0.0), and\nq4 = (-0.8, 0.0, -0.6, 0.0).\nFor the point p = (1.0, 1.0, 1.0), the following figures show the trajectories of p\nusing lerp, slerp, and squad.\n",
										"id": 289528640,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Quaternion",
										"scope": {
											"name": "Quaternion"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "bool",
						"builtin_type_kind": "bool",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Quaternion*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::getTranslation(stappler::geom::Vec3*) const",
					"_kind": "member function",
					"_name": "getTranslation",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 2000886348,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "getTranslation",
					"parameters": [{
						"_fullName": "translation",
						"_kind": "function parameter",
						"_name": "translation",
						"id": 2035964458,
						"kind": "function parameter",
						"name": "translation",
						"type": {
							"_typeName": "stappler::geom::Vec3*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Vec3",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec3",
									"objects": [{
										"_fullName": "::stappler::geom::Vec3",
										"_kind": "class",
										"_name": "Vec3",
										"class_kind": "class",
										"id": 748569271,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec3",
										"scope": {
											"name": "Vec3"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::getScale(float*) const",
					"_kind": "member function",
					"_name": "getScale",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 2900745244,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "getScale",
					"parameters": [{
						"_fullName": "scale",
						"_kind": "function parameter",
						"_name": "scale",
						"id": 4279669230,
						"kind": "function parameter",
						"name": "scale",
						"type": {
							"_typeName": "float*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "float",
								"builtin_type_kind": "float",
								"kind": "builtin"
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::getRotation(float*) const",
					"_kind": "member function",
					"_name": "getRotation",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 3975949652,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "getRotation",
					"parameters": [{
						"_fullName": "rotation",
						"_kind": "function parameter",
						"_name": "rotation",
						"id": 1688882020,
						"kind": "function parameter",
						"name": "rotation",
						"type": {
							"_typeName": "float*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "float",
								"builtin_type_kind": "float",
								"kind": "builtin"
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "bool",
						"builtin_type_kind": "bool",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::getTranslation(float*) const",
					"_kind": "member function",
					"_name": "getTranslation",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 4022490784,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "getTranslation",
					"parameters": [{
						"_fullName": "translation",
						"_kind": "function parameter",
						"_name": "translation",
						"id": 2035964458,
						"kind": "function parameter",
						"name": "translation",
						"type": {
							"_typeName": "float*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "float",
								"builtin_type_kind": "float",
								"kind": "builtin"
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::getUpVector(stappler::geom::Vec3*) const",
					"_kind": "member function",
					"_name": "getUpVector",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 2278766926,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "getUpVector",
					"parameters": [{
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Vec3*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Vec3",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec3",
									"objects": [{
										"_fullName": "::stappler::geom::Vec3",
										"_kind": "class",
										"_name": "Vec3",
										"class_kind": "class",
										"id": 748569271,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec3",
										"scope": {
											"name": "Vec3"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::getDownVector(stappler::geom::Vec3*) const",
					"_kind": "member function",
					"_name": "getDownVector",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 2853911628,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "getDownVector",
					"parameters": [{
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Vec3*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Vec3",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec3",
									"objects": [{
										"_fullName": "::stappler::geom::Vec3",
										"_kind": "class",
										"_name": "Vec3",
										"class_kind": "class",
										"id": 748569271,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec3",
										"scope": {
											"name": "Vec3"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::getLeftVector(stappler::geom::Vec3*) const",
					"_kind": "member function",
					"_name": "getLeftVector",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 1038130607,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "getLeftVector",
					"parameters": [{
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Vec3*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Vec3",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec3",
									"objects": [{
										"_fullName": "::stappler::geom::Vec3",
										"_kind": "class",
										"_name": "Vec3",
										"class_kind": "class",
										"id": 748569271,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec3",
										"scope": {
											"name": "Vec3"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::getRightVector(stappler::geom::Vec3*) const",
					"_kind": "member function",
					"_name": "getRightVector",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 1932022391,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "getRightVector",
					"parameters": [{
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Vec3*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Vec3",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec3",
									"objects": [{
										"_fullName": "::stappler::geom::Vec3",
										"_kind": "class",
										"_name": "Vec3",
										"class_kind": "class",
										"id": 748569271,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec3",
										"scope": {
											"name": "Vec3"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::getForwardVector(stappler::geom::Vec3*) const",
					"_kind": "member function",
					"_name": "getForwardVector",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 2112670213,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "getForwardVector",
					"parameters": [{
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Vec3*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Vec3",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec3",
									"objects": [{
										"_fullName": "::stappler::geom::Vec3",
										"_kind": "class",
										"_name": "Vec3",
										"class_kind": "class",
										"id": 748569271,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec3",
										"scope": {
											"name": "Vec3"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::getBackVector(stappler::geom::Vec3*) const",
					"_kind": "member function",
					"_name": "getBackVector",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 934529519,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "getBackVector",
					"parameters": [{
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Vec3*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Vec3",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec3",
									"objects": [{
										"_fullName": "::stappler::geom::Vec3",
										"_kind": "class",
										"_name": "Vec3",
										"class_kind": "class",
										"id": 748569271,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec3",
										"scope": {
											"name": "Vec3"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::inverse()",
					"_kind": "member function",
					"_name": "inverse",
					"body_kind": "declaration",
					"cv_qualifier": "none",
					"id": 3375977541,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "inverse",
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "bool",
						"builtin_type_kind": "bool",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "()"
				}, {
					"_fullName": "::stappler::geom::Mat4::negate()",
					"_kind": "member function",
					"_name": "negate",
					"body_kind": "definition",
					"cv_qualifier": "none",
					"id": 476051273,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "negate",
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "()"
				}, {
					"_fullName": "::stappler::geom::Mat4::transpose()",
					"_kind": "member function",
					"_name": "transpose",
					"body_kind": "definition",
					"cv_qualifier": "none",
					"id": 536543523,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "transpose",
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "()"
				}, {
					"_fullName": "::stappler::geom::Mat4::getInversed() const",
					"_kind": "member function",
					"_name": "getInversed",
					"body_kind": "definition",
					"cv_qualifier": "const",
					"id": 3072502283,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "getInversed",
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "stappler::geom::Mat4",
						"kind": "user_defined",
						"target": {
							"name": "stappler::geom::Mat4",
							"objects": [{
								"_fullName": "::stappler::geom::Mat4",
								"_kind": "class",
								"_name": "Mat4",
								"attributes": [{
									"arguments": [{
										"kind": "int_literal",
										"spelling": "16"
									}],
									"is_variadic": false,
									"kind": "alignas_",
									"name": "alignas"
								}],
								"class_kind": "class",
								"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
								"id": 3473668624,
								"is_declaration": false,
								"is_definition": true,
								"is_final": false,
								"kind": "class",
								"name": "Mat4",
								"scope": {
									"name": "Mat4"
								},
								"semantic_scope": ""
							}]
						}
					},
					"semantic_scope": "",
					"signature": "() const"
				}, {
					"_fullName": "::stappler::geom::Mat4::getNegated() const",
					"_kind": "member function",
					"_name": "getNegated",
					"body_kind": "definition",
					"cv_qualifier": "const",
					"id": 1563843405,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "getNegated",
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "stappler::geom::Mat4",
						"kind": "user_defined",
						"target": {
							"name": "stappler::geom::Mat4",
							"objects": [{
								"_fullName": "::stappler::geom::Mat4",
								"_kind": "class",
								"_name": "Mat4",
								"attributes": [{
									"arguments": [{
										"kind": "int_literal",
										"spelling": "16"
									}],
									"is_variadic": false,
									"kind": "alignas_",
									"name": "alignas"
								}],
								"class_kind": "class",
								"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
								"id": 3473668624,
								"is_declaration": false,
								"is_definition": true,
								"is_final": false,
								"kind": "class",
								"name": "Mat4",
								"scope": {
									"name": "Mat4"
								},
								"semantic_scope": ""
							}]
						}
					},
					"semantic_scope": "",
					"signature": "() const"
				}, {
					"_fullName": "::stappler::geom::Mat4::getTransposed() const",
					"_kind": "member function",
					"_name": "getTransposed",
					"body_kind": "definition",
					"cv_qualifier": "const",
					"id": 4175768874,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "getTransposed",
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "stappler::geom::Mat4",
						"kind": "user_defined",
						"target": {
							"name": "stappler::geom::Mat4",
							"objects": [{
								"_fullName": "::stappler::geom::Mat4",
								"_kind": "class",
								"_name": "Mat4",
								"attributes": [{
									"arguments": [{
										"kind": "int_literal",
										"spelling": "16"
									}],
									"is_variadic": false,
									"kind": "alignas_",
									"name": "alignas"
								}],
								"class_kind": "class",
								"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
								"id": 3473668624,
								"is_declaration": false,
								"is_definition": true,
								"is_final": false,
								"kind": "class",
								"name": "Mat4",
								"scope": {
									"name": "Mat4"
								},
								"semantic_scope": ""
							}]
						}
					},
					"semantic_scope": "",
					"signature": "() const"
				}, {
					"_fullName": "::stappler::geom::Mat4::isIdentity() const",
					"_kind": "member function",
					"_name": "isIdentity",
					"body_kind": "definition",
					"cv_qualifier": "const",
					"id": 2527063531,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "isIdentity",
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "bool",
						"builtin_type_kind": "bool",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "() const"
				}, {
					"_fullName": "::stappler::geom::Mat4::multiply(float)",
					"_kind": "member function",
					"_name": "multiply",
					"body_kind": "definition",
					"cv_qualifier": "none",
					"id": 3023487067,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "multiply",
					"parameters": [{
						"_fullName": "scalar",
						"_kind": "function parameter",
						"_name": "scalar",
						"id": 3137648071,
						"kind": "function parameter",
						"name": "scalar",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float)"
				}, {
					"_fullName": "::stappler::geom::Mat4::multiply(float,stappler::geom::Mat4*) const",
					"_kind": "member function",
					"_name": "multiply",
					"body_kind": "definition",
					"cv_qualifier": "const",
					"id": 2801386343,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "multiply",
					"parameters": [{
						"_fullName": "scalar",
						"_kind": "function parameter",
						"_name": "scalar",
						"id": 3137648071,
						"kind": "function parameter",
						"name": "scalar",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,stappler::geom::Mat4*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::multiply(stappler::geom::Mat4 const&)",
					"_kind": "member function",
					"_name": "multiply",
					"body_kind": "definition",
					"cv_qualifier": "none",
					"id": 295365483,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "multiply",
					"parameters": [{
						"_fullName": "mat",
						"_kind": "function parameter",
						"_name": "mat",
						"id": 247568213,
						"kind": "function parameter",
						"name": "mat",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Mat4 const&)"
				}, {
					"_fullName": "::stappler::geom::Mat4::rotate(stappler::geom::Quaternion const&)",
					"_kind": "member function",
					"_name": "rotate",
					"body_kind": "declaration",
					"cv_qualifier": "none",
					"id": 1006489288,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "rotate",
					"parameters": [{
						"_fullName": "q",
						"_kind": "function parameter",
						"_name": "q",
						"id": 2703191865,
						"kind": "function parameter",
						"name": "q",
						"type": {
							"_typeName": "stappler::geom::Quaternion const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Quaternion const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Quaternion",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Quaternion",
										"objects": [{
											"_fullName": "::stappler::geom::Quaternion",
											"_kind": "class",
											"_name": "Quaternion",
											"class_kind": "class",
											"comment": "\nDefines a 4-element quaternion that represents the orientation of an object in space.\n\nQuaternions are typically used as a replacement for euler angles and rotation matrices\nas a way to achieve smooth interpolation and avoid gimbal lock.\n\nNote that this quaternion class does not automatically keep the quaternion normalized.\nTherefore, care must be taken to normalize the quaternion when necessary, by calling\nthe normalize method.\nThis class provides three methods for doing quaternion interpolation: lerp, slerp, and squad.\n\nlerp (linear interpolation): the interpolation curve gives a straight line in quaternion\nspace. It is simple and fast to compute. The only problem is that it does not provide\nconstant angular velocity. Note that a constant velocity is not necessarily a requirement\nfor a curve;\nslerp (spherical linear interpolation): the interpolation curve forms a great arc on the\nquaternion unit sphere. Slerp provides constant angular velocity;\nsquad (spherical spline interpolation): interpolating between a series of rotations using\nslerp leads to the following problems:\n- the curve is not smooth at the control points;\n- the angular velocity is not constant;\n- the angular velocity is not continuous at the control points.\n\nSince squad is continuously differentiable, it remedies the first and third problems\nmentioned above.\nThe slerp method provided here is intended for interpolation of principal rotations.\nIt treats +q and -q as the same principal rotation and is at liberty to use the negative\nof either input. The resulting path is always the shorter arc.\n\nThe lerp method provided here interpolates strictly in quaternion space. Note that the\nresulting path may pass through the origin if interpolating between a quaternion and its\nexact negative.\n\nAs an example, consider the following quaternions:\n\nq1 = (0.6, 0.8, 0.0, 0.0),\nq2 = (0.0, 0.6, 0.8, 0.0),\nq3 = (0.6, 0.0, 0.8, 0.0), and\nq4 = (-0.8, 0.0, -0.6, 0.0).\nFor the point p = (1.0, 1.0, 1.0), the following figures show the trajectories of p\nusing lerp, slerp, and squad.\n",
											"id": 289528640,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Quaternion",
											"scope": {
												"name": "Quaternion"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Quaternion const&)"
				}, {
					"_fullName": "::stappler::geom::Mat4::rotate(stappler::geom::Quaternion const&,stappler::geom::Mat4*) const",
					"_kind": "member function",
					"_name": "rotate",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 3243336285,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "rotate",
					"parameters": [{
						"_fullName": "q",
						"_kind": "function parameter",
						"_name": "q",
						"id": 2703191865,
						"kind": "function parameter",
						"name": "q",
						"type": {
							"_typeName": "stappler::geom::Quaternion const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Quaternion const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Quaternion",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Quaternion",
										"objects": [{
											"_fullName": "::stappler::geom::Quaternion",
											"_kind": "class",
											"_name": "Quaternion",
											"class_kind": "class",
											"comment": "\nDefines a 4-element quaternion that represents the orientation of an object in space.\n\nQuaternions are typically used as a replacement for euler angles and rotation matrices\nas a way to achieve smooth interpolation and avoid gimbal lock.\n\nNote that this quaternion class does not automatically keep the quaternion normalized.\nTherefore, care must be taken to normalize the quaternion when necessary, by calling\nthe normalize method.\nThis class provides three methods for doing quaternion interpolation: lerp, slerp, and squad.\n\nlerp (linear interpolation): the interpolation curve gives a straight line in quaternion\nspace. It is simple and fast to compute. The only problem is that it does not provide\nconstant angular velocity. Note that a constant velocity is not necessarily a requirement\nfor a curve;\nslerp (spherical linear interpolation): the interpolation curve forms a great arc on the\nquaternion unit sphere. Slerp provides constant angular velocity;\nsquad (spherical spline interpolation): interpolating between a series of rotations using\nslerp leads to the following problems:\n- the curve is not smooth at the control points;\n- the angular velocity is not constant;\n- the angular velocity is not continuous at the control points.\n\nSince squad is continuously differentiable, it remedies the first and third problems\nmentioned above.\nThe slerp method provided here is intended for interpolation of principal rotations.\nIt treats +q and -q as the same principal rotation and is at liberty to use the negative\nof either input. The resulting path is always the shorter arc.\n\nThe lerp method provided here interpolates strictly in quaternion space. Note that the\nresulting path may pass through the origin if interpolating between a quaternion and its\nexact negative.\n\nAs an example, consider the following quaternions:\n\nq1 = (0.6, 0.8, 0.0, 0.0),\nq2 = (0.0, 0.6, 0.8, 0.0),\nq3 = (0.6, 0.0, 0.8, 0.0), and\nq4 = (-0.8, 0.0, -0.6, 0.0).\nFor the point p = (1.0, 1.0, 1.0), the following figures show the trajectories of p\nusing lerp, slerp, and squad.\n",
											"id": 289528640,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Quaternion",
											"scope": {
												"name": "Quaternion"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Quaternion const&,stappler::geom::Mat4*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::rotate(stappler::geom::Vec3 const&,float)",
					"_kind": "member function",
					"_name": "rotate",
					"body_kind": "declaration",
					"cv_qualifier": "none",
					"id": 3543213745,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "rotate",
					"parameters": [{
						"_fullName": "axis",
						"_kind": "function parameter",
						"_name": "axis",
						"id": 2450752328,
						"kind": "function parameter",
						"name": "axis",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "angle",
						"_kind": "function parameter",
						"_name": "angle",
						"id": 2170067527,
						"kind": "function parameter",
						"name": "angle",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3 const&,float)"
				}, {
					"_fullName": "::stappler::geom::Mat4::rotate(stappler::geom::Vec3 const&,float,stappler::geom::Mat4*) const",
					"_kind": "member function",
					"_name": "rotate",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 3796183241,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "rotate",
					"parameters": [{
						"_fullName": "axis",
						"_kind": "function parameter",
						"_name": "axis",
						"id": 2450752328,
						"kind": "function parameter",
						"name": "axis",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "angle",
						"_kind": "function parameter",
						"_name": "angle",
						"id": 2170067527,
						"kind": "function parameter",
						"name": "angle",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3 const&,float,stappler::geom::Mat4*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::rotateX(float)",
					"_kind": "member function",
					"_name": "rotateX",
					"body_kind": "declaration",
					"cv_qualifier": "none",
					"id": 1736688264,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "rotateX",
					"parameters": [{
						"_fullName": "angle",
						"_kind": "function parameter",
						"_name": "angle",
						"id": 2170067527,
						"kind": "function parameter",
						"name": "angle",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float)"
				}, {
					"_fullName": "::stappler::geom::Mat4::rotateX(float,stappler::geom::Mat4*) const",
					"_kind": "member function",
					"_name": "rotateX",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 955155623,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "rotateX",
					"parameters": [{
						"_fullName": "angle",
						"_kind": "function parameter",
						"_name": "angle",
						"id": 2170067527,
						"kind": "function parameter",
						"name": "angle",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,stappler::geom::Mat4*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::rotateY(float)",
					"_kind": "member function",
					"_name": "rotateY",
					"body_kind": "declaration",
					"cv_qualifier": "none",
					"id": 692035706,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "rotateY",
					"parameters": [{
						"_fullName": "angle",
						"_kind": "function parameter",
						"_name": "angle",
						"id": 2170067527,
						"kind": "function parameter",
						"name": "angle",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float)"
				}, {
					"_fullName": "::stappler::geom::Mat4::rotateY(float,stappler::geom::Mat4*) const",
					"_kind": "member function",
					"_name": "rotateY",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 2780237151,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "rotateY",
					"parameters": [{
						"_fullName": "angle",
						"_kind": "function parameter",
						"_name": "angle",
						"id": 2170067527,
						"kind": "function parameter",
						"name": "angle",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,stappler::geom::Mat4*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::rotateZ(float)",
					"_kind": "member function",
					"_name": "rotateZ",
					"body_kind": "declaration",
					"cv_qualifier": "none",
					"id": 1979985445,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "rotateZ",
					"parameters": [{
						"_fullName": "angle",
						"_kind": "function parameter",
						"_name": "angle",
						"id": 2170067527,
						"kind": "function parameter",
						"name": "angle",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float)"
				}, {
					"_fullName": "::stappler::geom::Mat4::rotateZ(float,stappler::geom::Mat4*) const",
					"_kind": "member function",
					"_name": "rotateZ",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 3687934543,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "rotateZ",
					"parameters": [{
						"_fullName": "angle",
						"_kind": "function parameter",
						"_name": "angle",
						"id": 2170067527,
						"kind": "function parameter",
						"name": "angle",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,stappler::geom::Mat4*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::scale(float)",
					"_kind": "member function",
					"_name": "scale",
					"body_kind": "declaration",
					"cv_qualifier": "none",
					"id": 456793465,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "scale",
					"parameters": [{
						"_fullName": "value",
						"_kind": "function parameter",
						"_name": "value",
						"id": 4105109168,
						"kind": "function parameter",
						"name": "value",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float)"
				}, {
					"_fullName": "::stappler::geom::Mat4::scale(float,stappler::geom::Mat4*) const",
					"_kind": "member function",
					"_name": "scale",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 81468669,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "scale",
					"parameters": [{
						"_fullName": "value",
						"_kind": "function parameter",
						"_name": "value",
						"id": 4105109168,
						"kind": "function parameter",
						"name": "value",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,stappler::geom::Mat4*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::scale(float,float,float)",
					"_kind": "member function",
					"_name": "scale",
					"body_kind": "declaration",
					"cv_qualifier": "none",
					"id": 2350555822,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "scale",
					"parameters": [{
						"_fullName": "xScale",
						"_kind": "function parameter",
						"_name": "xScale",
						"id": 1067724672,
						"kind": "function parameter",
						"name": "xScale",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "yScale",
						"_kind": "function parameter",
						"_name": "yScale",
						"id": 2643966016,
						"kind": "function parameter",
						"name": "yScale",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "zScale",
						"_kind": "function parameter",
						"_name": "zScale",
						"id": 2429227741,
						"kind": "function parameter",
						"name": "zScale",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,float,float)"
				}, {
					"_fullName": "::stappler::geom::Mat4::scale(float,float,float,stappler::geom::Mat4*) const",
					"_kind": "member function",
					"_name": "scale",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 3160032144,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "scale",
					"parameters": [{
						"_fullName": "xScale",
						"_kind": "function parameter",
						"_name": "xScale",
						"id": 1067724672,
						"kind": "function parameter",
						"name": "xScale",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "yScale",
						"_kind": "function parameter",
						"_name": "yScale",
						"id": 2643966016,
						"kind": "function parameter",
						"name": "yScale",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "zScale",
						"_kind": "function parameter",
						"_name": "zScale",
						"id": 2429227741,
						"kind": "function parameter",
						"name": "zScale",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,float,float,stappler::geom::Mat4*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::scale(stappler::geom::Vec3 const&)",
					"_kind": "member function",
					"_name": "scale",
					"body_kind": "declaration",
					"cv_qualifier": "none",
					"id": 4279203019,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "scale",
					"parameters": [{
						"_fullName": "s",
						"_kind": "function parameter",
						"_name": "s",
						"id": 974162354,
						"kind": "function parameter",
						"name": "s",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3 const&)"
				}, {
					"_fullName": "::stappler::geom::Mat4::scale(stappler::geom::Vec3 const&,stappler::geom::Mat4*) const",
					"_kind": "member function",
					"_name": "scale",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 3661047570,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "scale",
					"parameters": [{
						"_fullName": "s",
						"_kind": "function parameter",
						"_name": "s",
						"id": 974162354,
						"kind": "function parameter",
						"name": "s",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3 const&,stappler::geom::Mat4*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::subtract(stappler::geom::Mat4 const&)",
					"_kind": "member function",
					"_name": "subtract",
					"body_kind": "definition",
					"cv_qualifier": "none",
					"id": 3622784552,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "subtract",
					"parameters": [{
						"_fullName": "mat",
						"_kind": "function parameter",
						"_name": "mat",
						"id": 247568213,
						"kind": "function parameter",
						"name": "mat",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Mat4 const&)"
				}, {
					"_fullName": "::stappler::geom::Mat4::transformPoint(stappler::geom::Vec2 const&) const",
					"_kind": "member function",
					"_name": "transformPoint",
					"body_kind": "definition",
					"cv_qualifier": "const",
					"id": 1022745653,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "transformPoint",
					"parameters": [{
						"_fullName": "point",
						"_kind": "function parameter",
						"_name": "point",
						"id": 3823300211,
						"kind": "function parameter",
						"name": "point",
						"type": {
							"_typeName": "stappler::geom::Vec2 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec2 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec2",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec2",
										"objects": [{
											"_fullName": "::stappler::geom::Vec2",
											"_kind": "class",
											"_name": "Vec2",
											"class_kind": "class",
											"id": 16661423,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec2",
											"scope": {
												"name": "Vec2"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "stappler::geom::Vec2",
						"kind": "user_defined",
						"target": {
							"name": "stappler::geom::Vec2",
							"objects": [{
								"_fullName": "::stappler::geom::Vec2",
								"_kind": "class",
								"_name": "Vec2",
								"class_kind": "class",
								"id": 16661423,
								"is_declaration": false,
								"is_definition": true,
								"is_final": false,
								"kind": "class",
								"name": "Vec2",
								"scope": {
									"name": "Vec2"
								},
								"semantic_scope": ""
							}]
						}
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec2 const&) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::transformPoint(stappler::geom::Vec2*) const",
					"_kind": "member function",
					"_name": "transformPoint",
					"body_kind": "definition",
					"cv_qualifier": "const",
					"id": 701152751,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "transformPoint",
					"parameters": [{
						"_fullName": "point",
						"_kind": "function parameter",
						"_name": "point",
						"id": 3823300211,
						"kind": "function parameter",
						"name": "point",
						"type": {
							"_typeName": "stappler::geom::Vec2*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Vec2",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec2",
									"objects": [{
										"_fullName": "::stappler::geom::Vec2",
										"_kind": "class",
										"_name": "Vec2",
										"class_kind": "class",
										"id": 16661423,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec2",
										"scope": {
											"name": "Vec2"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec2*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::transformVector(stappler::geom::Vec4*) const",
					"_kind": "member function",
					"_name": "transformVector",
					"body_kind": "definition",
					"cv_qualifier": "const",
					"id": 1264557944,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "transformVector",
					"parameters": [{
						"_fullName": "vector",
						"_kind": "function parameter",
						"_name": "vector",
						"id": 1906722629,
						"kind": "function parameter",
						"name": "vector",
						"type": {
							"_typeName": "stappler::geom::Vec4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Vec4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec4",
									"objects": [{
										"_fullName": "::stappler::geom::Vec4",
										"_kind": "class",
										"_name": "Vec4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"id": 2114633745,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec4",
										"scope": {
											"name": "Vec4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec4*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::transformVector(float,float,float,float,stappler::geom::Vec4*) const",
					"_kind": "member function",
					"_name": "transformVector",
					"body_kind": "definition",
					"cv_qualifier": "const",
					"id": 2973581318,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "transformVector",
					"parameters": [{
						"_fullName": "x",
						"_kind": "function parameter",
						"_name": "x",
						"id": 784609514,
						"kind": "function parameter",
						"name": "x",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "y",
						"_kind": "function parameter",
						"_name": "y",
						"id": 2956175415,
						"kind": "function parameter",
						"name": "y",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "z",
						"_kind": "function parameter",
						"_name": "z",
						"id": 2804950734,
						"kind": "function parameter",
						"name": "z",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "w",
						"_kind": "function parameter",
						"_name": "w",
						"id": 3698808529,
						"kind": "function parameter",
						"name": "w",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Vec4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Vec4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec4",
									"objects": [{
										"_fullName": "::stappler::geom::Vec4",
										"_kind": "class",
										"_name": "Vec4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"id": 2114633745,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec4",
										"scope": {
											"name": "Vec4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,float,float,float,stappler::geom::Vec4*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::transformVector(float,float,float,float,float*) const",
					"_kind": "member function",
					"_name": "transformVector",
					"body_kind": "definition",
					"cv_qualifier": "const",
					"id": 622857140,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "transformVector",
					"parameters": [{
						"_fullName": "x",
						"_kind": "function parameter",
						"_name": "x",
						"id": 784609514,
						"kind": "function parameter",
						"name": "x",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "y",
						"_kind": "function parameter",
						"_name": "y",
						"id": 2956175415,
						"kind": "function parameter",
						"name": "y",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "z",
						"_kind": "function parameter",
						"_name": "z",
						"id": 2804950734,
						"kind": "function parameter",
						"name": "z",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "w",
						"_kind": "function parameter",
						"_name": "w",
						"id": 3698808529,
						"kind": "function parameter",
						"name": "w",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "float*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "float",
								"builtin_type_kind": "float",
								"kind": "builtin"
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,float,float,float,float*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::transformVector(stappler::geom::Vec4 const&,stappler::geom::Vec4*) const",
					"_kind": "member function",
					"_name": "transformVector",
					"body_kind": "definition",
					"cv_qualifier": "const",
					"id": 3705674911,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "transformVector",
					"parameters": [{
						"_fullName": "vector",
						"_kind": "function parameter",
						"_name": "vector",
						"id": 1906722629,
						"kind": "function parameter",
						"name": "vector",
						"type": {
							"_typeName": "stappler::geom::Vec4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec4",
										"objects": [{
											"_fullName": "::stappler::geom::Vec4",
											"_kind": "class",
											"_name": "Vec4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"id": 2114633745,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec4",
											"scope": {
												"name": "Vec4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Vec4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Vec4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec4",
									"objects": [{
										"_fullName": "::stappler::geom::Vec4",
										"_kind": "class",
										"_name": "Vec4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"id": 2114633745,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec4",
										"scope": {
											"name": "Vec4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec4 const&,stappler::geom::Vec4*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::transformVector(stappler::geom::Vec4 const&,stappler::geom::Vec3*) const",
					"_kind": "member function",
					"_name": "transformVector",
					"body_kind": "definition",
					"cv_qualifier": "const",
					"id": 2292585411,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "transformVector",
					"parameters": [{
						"_fullName": "vector",
						"_kind": "function parameter",
						"_name": "vector",
						"id": 1906722629,
						"kind": "function parameter",
						"name": "vector",
						"type": {
							"_typeName": "stappler::geom::Vec4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec4",
										"objects": [{
											"_fullName": "::stappler::geom::Vec4",
											"_kind": "class",
											"_name": "Vec4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"id": 2114633745,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec4",
											"scope": {
												"name": "Vec4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Vec3*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Vec3",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec3",
									"objects": [{
										"_fullName": "::stappler::geom::Vec3",
										"_kind": "class",
										"_name": "Vec3",
										"class_kind": "class",
										"id": 748569271,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec3",
										"scope": {
											"name": "Vec3"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec4 const&,stappler::geom::Vec3*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::translate(float,float,float)",
					"_kind": "member function",
					"_name": "translate",
					"body_kind": "declaration",
					"cv_qualifier": "none",
					"id": 2797715722,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "translate",
					"parameters": [{
						"_fullName": "x",
						"_kind": "function parameter",
						"_name": "x",
						"id": 784609514,
						"kind": "function parameter",
						"name": "x",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "y",
						"_kind": "function parameter",
						"_name": "y",
						"id": 2956175415,
						"kind": "function parameter",
						"name": "y",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "z",
						"_kind": "function parameter",
						"_name": "z",
						"id": 2804950734,
						"kind": "function parameter",
						"name": "z",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,float,float)"
				}, {
					"_fullName": "::stappler::geom::Mat4::translate(float,float,float,stappler::geom::Mat4*) const",
					"_kind": "member function",
					"_name": "translate",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 385256542,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "translate",
					"parameters": [{
						"_fullName": "x",
						"_kind": "function parameter",
						"_name": "x",
						"id": 784609514,
						"kind": "function parameter",
						"name": "x",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "y",
						"_kind": "function parameter",
						"_name": "y",
						"id": 2956175415,
						"kind": "function parameter",
						"name": "y",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "z",
						"_kind": "function parameter",
						"_name": "z",
						"id": 2804950734,
						"kind": "function parameter",
						"name": "z",
						"type": {
							"_typeName": "float",
							"builtin_type_kind": "float",
							"kind": "builtin"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(float,float,float,stappler::geom::Mat4*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::translate(stappler::geom::Vec3 const&)",
					"_kind": "member function",
					"_name": "translate",
					"body_kind": "declaration",
					"cv_qualifier": "none",
					"id": 3178404299,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "translate",
					"parameters": [{
						"_fullName": "t",
						"_kind": "function parameter",
						"_name": "t",
						"id": 4086942996,
						"kind": "function parameter",
						"name": "t",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3 const&)"
				}, {
					"_fullName": "::stappler::geom::Mat4::translate(stappler::geom::Vec3 const&,stappler::geom::Mat4*) const",
					"_kind": "member function",
					"_name": "translate",
					"body_kind": "declaration",
					"cv_qualifier": "const",
					"id": 1003282123,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "translate",
					"parameters": [{
						"_fullName": "t",
						"_kind": "function parameter",
						"_name": "t",
						"id": 4086942996,
						"kind": "function parameter",
						"name": "t",
						"type": {
							"_typeName": "stappler::geom::Vec3 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Vec3 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Vec3",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Vec3",
										"objects": [{
											"_fullName": "::stappler::geom::Vec3",
											"_kind": "class",
											"_name": "Vec3",
											"class_kind": "class",
											"id": 748569271,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Vec3",
											"scope": {
												"name": "Vec3"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}, {
						"_fullName": "dst",
						"_kind": "function parameter",
						"_name": "dst",
						"id": 3700855415,
						"kind": "function parameter",
						"name": "dst",
						"type": {
							"_typeName": "stappler::geom::Mat4*",
							"kind": "pointer",
							"pointee": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "void",
						"builtin_type_kind": "void",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Vec3 const&,stappler::geom::Mat4*) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::operator+(stappler::geom::Mat4 const&) const",
					"_kind": "member function",
					"_name": "operator+",
					"body_kind": "definition",
					"cv_qualifier": "const",
					"id": 2486673347,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "operator+",
					"parameters": [{
						"_fullName": "mat",
						"_kind": "function parameter",
						"_name": "mat",
						"id": 247568213,
						"kind": "function parameter",
						"name": "mat",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "stappler::geom::Mat4 const",
						"cv_qualifier": "const",
						"kind": "cv_qualified",
						"type": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						}
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Mat4 const&) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::operator+=(stappler::geom::Mat4 const&)",
					"_kind": "member function",
					"_name": "operator+=",
					"body_kind": "definition",
					"cv_qualifier": "none",
					"id": 4130315978,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "operator+=",
					"parameters": [{
						"_fullName": "mat",
						"_kind": "function parameter",
						"_name": "mat",
						"id": 247568213,
						"kind": "function parameter",
						"name": "mat",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "stappler::geom::Mat4&",
						"kind": "reference",
						"referee": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						},
						"reference_kind": "lvalue"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Mat4 const&)"
				}, {
					"_fullName": "::stappler::geom::Mat4::operator-(stappler::geom::Mat4 const&) const",
					"_kind": "member function",
					"_name": "operator-",
					"body_kind": "definition",
					"cv_qualifier": "const",
					"id": 3519565802,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "operator-",
					"parameters": [{
						"_fullName": "mat",
						"_kind": "function parameter",
						"_name": "mat",
						"id": 247568213,
						"kind": "function parameter",
						"name": "mat",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "stappler::geom::Mat4 const",
						"cv_qualifier": "const",
						"kind": "cv_qualified",
						"type": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						}
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Mat4 const&) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::operator-=(stappler::geom::Mat4 const&)",
					"_kind": "member function",
					"_name": "operator-=",
					"body_kind": "definition",
					"cv_qualifier": "none",
					"id": 3622855446,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "operator-=",
					"parameters": [{
						"_fullName": "mat",
						"_kind": "function parameter",
						"_name": "mat",
						"id": 247568213,
						"kind": "function parameter",
						"name": "mat",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "stappler::geom::Mat4&",
						"kind": "reference",
						"referee": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						},
						"reference_kind": "lvalue"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Mat4 const&)"
				}, {
					"_fullName": "::stappler::geom::Mat4::operator-() const",
					"_kind": "member function",
					"_name": "operator-",
					"body_kind": "definition",
					"cv_qualifier": "const",
					"id": 2638121081,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "operator-",
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "stappler::geom::Mat4 const",
						"cv_qualifier": "const",
						"kind": "cv_qualified",
						"type": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						}
					},
					"semantic_scope": "",
					"signature": "() const"
				}, {
					"_fullName": "::stappler::geom::Mat4::operator*(stappler::geom::Mat4 const&) const",
					"_kind": "member function",
					"_name": "operator*",
					"body_kind": "definition",
					"cv_qualifier": "const",
					"id": 3772431711,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "operator*",
					"parameters": [{
						"_fullName": "mat",
						"_kind": "function parameter",
						"_name": "mat",
						"id": 247568213,
						"kind": "function parameter",
						"name": "mat",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "stappler::geom::Mat4 const",
						"cv_qualifier": "const",
						"kind": "cv_qualified",
						"type": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						}
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Mat4 const&) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::operator*=(stappler::geom::Mat4 const&)",
					"_kind": "member function",
					"_name": "operator*=",
					"body_kind": "definition",
					"cv_qualifier": "none",
					"id": 1077626061,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "operator*=",
					"parameters": [{
						"_fullName": "mat",
						"_kind": "function parameter",
						"_name": "mat",
						"id": 247568213,
						"kind": "function parameter",
						"name": "mat",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "stappler::geom::Mat4&",
						"kind": "reference",
						"referee": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						},
						"reference_kind": "lvalue"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Mat4 const&)"
				}, {
					"_fullName": "::stappler::geom::Mat4::operator==(stappler::geom::Mat4 const&) const",
					"_kind": "member function",
					"_name": "operator==",
					"body_kind": "defaulted",
					"cv_qualifier": "const",
					"id": 2323929272,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "operator==",
					"parameters": [{
						"_fullName": "",
						"_kind": "function parameter",
						"_name": "",
						"id": 46947589,
						"kind": "function parameter",
						"name": "",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "bool",
						"builtin_type_kind": "bool",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Mat4 const&) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::operator!=(stappler::geom::Mat4 const&) const",
					"_kind": "member function",
					"_name": "operator!=",
					"body_kind": "defaulted",
					"cv_qualifier": "const",
					"id": 2976448986,
					"is_consteval": false,
					"is_constexpr": false,
					"is_declaration": false,
					"is_definition": true,
					"is_variadic": false,
					"is_virtual": false,
					"kind": "member function",
					"name": "operator!=",
					"parameters": [{
						"_fullName": "",
						"_kind": "function parameter",
						"_name": "",
						"id": 46947589,
						"kind": "function parameter",
						"name": "",
						"type": {
							"_typeName": "stappler::geom::Mat4 const&",
							"kind": "reference",
							"referee": {
								"_typeName": "stappler::geom::Mat4 const",
								"cv_qualifier": "const",
								"kind": "cv_qualified",
								"type": {
									"_typeName": "stappler::geom::Mat4",
									"kind": "user_defined",
									"target": {
										"name": "stappler::geom::Mat4",
										"objects": [{
											"_fullName": "::stappler::geom::Mat4",
											"_kind": "class",
											"_name": "Mat4",
											"attributes": [{
												"arguments": [{
													"kind": "int_literal",
													"spelling": "16"
												}],
												"is_variadic": false,
												"kind": "alignas_",
												"name": "alignas"
											}],
											"class_kind": "class",
											"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
											"id": 3473668624,
											"is_declaration": false,
											"is_definition": true,
											"is_final": false,
											"kind": "class",
											"name": "Mat4",
											"scope": {
												"name": "Mat4"
											},
											"semantic_scope": ""
										}]
									}
								}
							},
							"reference_kind": "lvalue"
						}
					}],
					"ref_qualifier": "none",
					"return_type": {
						"_typeName": "bool",
						"builtin_type_kind": "bool",
						"kind": "builtin"
					},
					"semantic_scope": "",
					"signature": "(stappler::geom::Mat4 const&) const"
				}, {
					"_fullName": "::stappler::geom::Mat4::ZERO",
					"_kind": "variable",
					"_name": "ZERO",
					"id": 2222357871,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"kind": "variable",
					"name": "ZERO",
					"semantic_scope": "",
					"storage_class": [
						"static"
					],
					"type":  {
						"_typeName": "stappler::geom::Mat4 const",
						"cv_qualifier": "const",
						"kind": "cv_qualified",
						"type": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						}
					}
				}, {
					"_fullName": "::stappler::geom::Mat4::IDENTITY",
					"_kind": "variable",
					"_name": "IDENTITY",
					"id": 4188583448,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"kind": "variable",
					"name": "IDENTITY",
					"semantic_scope": "",
					"storage_class": [
						"static"
					],
					"type":  {
						"_typeName": "stappler::geom::Mat4 const",
						"cv_qualifier": "const",
						"kind": "cv_qualified",
						"type": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						}
					}
				}, {
					"_fullName": "::stappler::geom::Mat4::INVALID",
					"_kind": "variable",
					"_name": "INVALID",
					"id": 1201928169,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"kind": "variable",
					"name": "INVALID",
					"semantic_scope": "",
					"storage_class": [
						"static"
					],
					"type":  {
						"_typeName": "stappler::geom::Mat4 const",
						"cv_qualifier": "const",
						"kind": "cv_qualified",
						"type": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						}
					}
				}, {
					"_fullName": "::stappler::geom::Mat4::ROTATION_Z_90",
					"_kind": "variable",
					"_name": "ROTATION_Z_90",
					"id": 2844866488,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"kind": "variable",
					"name": "ROTATION_Z_90",
					"semantic_scope": "",
					"storage_class": [
						"static"
					],
					"type":  {
						"_typeName": "stappler::geom::Mat4 const",
						"cv_qualifier": "const",
						"kind": "cv_qualified",
						"type": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						}
					}
				}, {
					"_fullName": "::stappler::geom::Mat4::ROTATION_Z_180",
					"_kind": "variable",
					"_name": "ROTATION_Z_180",
					"id": 3298642523,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"kind": "variable",
					"name": "ROTATION_Z_180",
					"semantic_scope": "",
					"storage_class": [
						"static"
					],
					"type":  {
						"_typeName": "stappler::geom::Mat4 const",
						"cv_qualifier": "const",
						"kind": "cv_qualified",
						"type": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						}
					}
				}, {
					"_fullName": "::stappler::geom::Mat4::ROTATION_Z_270",
					"_kind": "variable",
					"_name": "ROTATION_Z_270",
					"id": 3684522809,
					"is_constexpr": false,
					"is_declaration": true,
					"is_definition": false,
					"kind": "variable",
					"name": "ROTATION_Z_270",
					"semantic_scope": "",
					"storage_class": [
						"static"
					],
					"type":  {
						"_typeName": "stappler::geom::Mat4 const",
						"cv_qualifier": "const",
						"kind": "cv_qualified",
						"type": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						}
					}
				}],
				"class_kind": "class",
				"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
				"id": 3473668624,
				"is_declaration": false,
				"is_definition": true,
				"is_final": false,
				"kind": "class",
				"name": "Mat4",
				"scope": {
					"name": "Mat4"
				},
				"semantic_scope": ""
			}, {
				"_fullName": "::stappler::geom::Mat4::IDENTITY",
				"_kind": "variable",
				"_name": "IDENTITY",
				"default_value": {
					"expression": [{
						"kind": "identifier",
						"spelling": "Mat4"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "float_literal",
						"spelling": "1.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "1.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "1.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "1.0f"
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}],
					"kind": "unexposed",
					"type": {
						"_typeName": "stappler::geom::Mat4 const",
						"cv_qualifier": "const",
						"kind": "cv_qualified",
						"type": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						}
					}
				},
				"id": 4188583448,
				"is_constexpr": true,
				"is_declaration": false,
				"is_definition": true,
				"kind": "variable",
				"name": "IDENTITY",
				"semantic_parent": {
					"name": "Mat4::",
					"objects": [{
						"_fullName": "::stappler::geom::Mat4",
						"_kind": "class",
						"_name": "Mat4",
						"attributes": [{
							"arguments": [{
								"kind": "int_literal",
								"spelling": "16"
							}],
							"is_variadic": false,
							"kind": "alignas_",
							"name": "alignas"
						}],
						"class_kind": "class",
						"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
						"id": 3473668624,
						"is_declaration": false,
						"is_definition": true,
						"is_final": false,
						"kind": "class",
						"name": "Mat4",
						"scope": {
							"name": "Mat4"
						},
						"semantic_scope": ""
					}]
				},
				"semantic_scope": "Mat4::",
				"type": {
					"_typeName": "stappler::geom::Mat4 const",
					"cv_qualifier": "const",
					"kind": "cv_qualified",
					"type": {
						"_typeName": "stappler::geom::Mat4",
						"kind": "user_defined",
						"target": {
							"name": "stappler::geom::Mat4",
							"objects": [{
								"_fullName": "::stappler::geom::Mat4",
								"_kind": "class",
								"_name": "Mat4",
								"attributes": [{
									"arguments": [{
										"kind": "int_literal",
										"spelling": "16"
									}],
									"is_variadic": false,
									"kind": "alignas_",
									"name": "alignas"
								}],
								"class_kind": "class",
								"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
								"id": 3473668624,
								"is_declaration": false,
								"is_definition": true,
								"is_final": false,
								"kind": "class",
								"name": "Mat4",
								"scope": {
									"name": "Mat4"
								},
								"semantic_scope": ""
							}]
						}
					}
				}
			}, {
				"_fullName": "::stappler::geom::Mat4::ZERO",
				"_kind": "variable",
				"_name": "ZERO",
				"default_value": {
					"expression": [{
						"kind": "identifier",
						"spelling": "Mat4"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}],
					"kind": "unexposed",
					"type": {
						"_typeName": "stappler::geom::Mat4 const",
						"cv_qualifier": "const",
						"kind": "cv_qualified",
						"type": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						}
					}
				},
				"id": 2222357871,
				"is_constexpr": true,
				"is_declaration": false,
				"is_definition": true,
				"kind": "variable",
				"name": "ZERO",
				"semantic_parent": {
					"name": "Mat4::",
					"objects": [{
						"_fullName": "::stappler::geom::Mat4",
						"_kind": "class",
						"_name": "Mat4",
						"attributes": [{
							"arguments": [{
								"kind": "int_literal",
								"spelling": "16"
							}],
							"is_variadic": false,
							"kind": "alignas_",
							"name": "alignas"
						}],
						"class_kind": "class",
						"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
						"id": 3473668624,
						"is_declaration": false,
						"is_definition": true,
						"is_final": false,
						"kind": "class",
						"name": "Mat4",
						"scope": {
							"name": "Mat4"
						},
						"semantic_scope": ""
					}]
				},
				"semantic_scope": "Mat4::",
				"type": {
					"_typeName": "stappler::geom::Mat4 const",
					"cv_qualifier": "const",
					"kind": "cv_qualified",
					"type": {
						"_typeName": "stappler::geom::Mat4",
						"kind": "user_defined",
						"target": {
							"name": "stappler::geom::Mat4",
							"objects": [{
								"_fullName": "::stappler::geom::Mat4",
								"_kind": "class",
								"_name": "Mat4",
								"attributes": [{
									"arguments": [{
										"kind": "int_literal",
										"spelling": "16"
									}],
									"is_variadic": false,
									"kind": "alignas_",
									"name": "alignas"
								}],
								"class_kind": "class",
								"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
								"id": 3473668624,
								"is_declaration": false,
								"is_definition": true,
								"is_final": false,
								"kind": "class",
								"name": "Mat4",
								"scope": {
									"name": "Mat4"
								},
								"semantic_scope": ""
							}]
						}
					}
				}
			}, {
				"_fullName": "::stappler::geom::Mat4::INVALID",
				"_kind": "variable",
				"_name": "INVALID",
				"default_value": {
					"expression": [{
						"kind": "identifier",
						"spelling": "Mat4"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "identifier",
						"spelling": "stappler"
					}, {
						"kind": "punctuation",
						"spelling": "::"
					}, {
						"kind": "identifier",
						"spelling": "nan"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "identifier",
						"spelling": "stappler"
					}, {
						"kind": "punctuation",
						"spelling": "::"
					}, {
						"kind": "identifier",
						"spelling": "nan"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "identifier",
						"spelling": "stappler"
					}, {
						"kind": "punctuation",
						"spelling": "::"
					}, {
						"kind": "identifier",
						"spelling": "nan"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "identifier",
						"spelling": "stappler"
					}, {
						"kind": "punctuation",
						"spelling": "::"
					}, {
						"kind": "identifier",
						"spelling": "nan"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "identifier",
						"spelling": "stappler"
					}, {
						"kind": "punctuation",
						"spelling": "::"
					}, {
						"kind": "identifier",
						"spelling": "nan"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "identifier",
						"spelling": "stappler"
					}, {
						"kind": "punctuation",
						"spelling": "::"
					}, {
						"kind": "identifier",
						"spelling": "nan"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "identifier",
						"spelling": "stappler"
					}, {
						"kind": "punctuation",
						"spelling": "::"
					}, {
						"kind": "identifier",
						"spelling": "nan"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "identifier",
						"spelling": "stappler"
					}, {
						"kind": "punctuation",
						"spelling": "::"
					}, {
						"kind": "identifier",
						"spelling": "nan"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "identifier",
						"spelling": "stappler"
					}, {
						"kind": "punctuation",
						"spelling": "::"
					}, {
						"kind": "identifier",
						"spelling": "nan"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "identifier",
						"spelling": "stappler"
					}, {
						"kind": "punctuation",
						"spelling": "::"
					}, {
						"kind": "identifier",
						"spelling": "nan"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "identifier",
						"spelling": "stappler"
					}, {
						"kind": "punctuation",
						"spelling": "::"
					}, {
						"kind": "identifier",
						"spelling": "nan"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "identifier",
						"spelling": "stappler"
					}, {
						"kind": "punctuation",
						"spelling": "::"
					}, {
						"kind": "identifier",
						"spelling": "nan"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "identifier",
						"spelling": "stappler"
					}, {
						"kind": "punctuation",
						"spelling": "::"
					}, {
						"kind": "identifier",
						"spelling": "nan"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "identifier",
						"spelling": "stappler"
					}, {
						"kind": "punctuation",
						"spelling": "::"
					}, {
						"kind": "identifier",
						"spelling": "nan"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "identifier",
						"spelling": "stappler"
					}, {
						"kind": "punctuation",
						"spelling": "::"
					}, {
						"kind": "identifier",
						"spelling": "nan"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "identifier",
						"spelling": "stappler"
					}, {
						"kind": "punctuation",
						"spelling": "::"
					}, {
						"kind": "identifier",
						"spelling": "nan"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}],
					"kind": "unexposed",
					"type": {
						"_typeName": "stappler::geom::Mat4 const",
						"cv_qualifier": "const",
						"kind": "cv_qualified",
						"type": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						}
					}
				},
				"id": 1201928169,
				"is_constexpr": true,
				"is_declaration": false,
				"is_definition": true,
				"kind": "variable",
				"name": "INVALID",
				"semantic_parent": {
					"name": "Mat4::",
					"objects": [{
						"_fullName": "::stappler::geom::Mat4",
						"_kind": "class",
						"_name": "Mat4",
						"attributes": [{
							"arguments": [{
								"kind": "int_literal",
								"spelling": "16"
							}],
							"is_variadic": false,
							"kind": "alignas_",
							"name": "alignas"
						}],
						"class_kind": "class",
						"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
						"id": 3473668624,
						"is_declaration": false,
						"is_definition": true,
						"is_final": false,
						"kind": "class",
						"name": "Mat4",
						"scope": {
							"name": "Mat4"
						},
						"semantic_scope": ""
					}]
				},
				"semantic_scope": "Mat4::",
				"type": {
					"_typeName": "stappler::geom::Mat4 const",
					"cv_qualifier": "const",
					"kind": "cv_qualified",
					"type": {
						"_typeName": "stappler::geom::Mat4",
						"kind": "user_defined",
						"target": {
							"name": "stappler::geom::Mat4",
							"objects": [{
								"_fullName": "::stappler::geom::Mat4",
								"_kind": "class",
								"_name": "Mat4",
								"attributes": [{
									"arguments": [{
										"kind": "int_literal",
										"spelling": "16"
									}],
									"is_variadic": false,
									"kind": "alignas_",
									"name": "alignas"
								}],
								"class_kind": "class",
								"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
								"id": 3473668624,
								"is_declaration": false,
								"is_definition": true,
								"is_final": false,
								"kind": "class",
								"name": "Mat4",
								"scope": {
									"name": "Mat4"
								},
								"semantic_scope": ""
							}]
						}
					}
				}
			}, {
				"_fullName": "::stappler::geom::Mat4::ROTATION_Z_90",
				"_kind": "variable",
				"_name": "ROTATION_Z_90",
				"default_value": {
					"expression": [{
						"kind": "identifier",
						"spelling": "Mat4"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "punctuation",
						"spelling": "-"
					}, {
						"kind": "float_literal",
						"spelling": "1.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "1.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "1.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "1.0f"
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}],
					"kind": "unexposed",
					"type": {
						"_typeName": "stappler::geom::Mat4 const",
						"cv_qualifier": "const",
						"kind": "cv_qualified",
						"type": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						}
					}
				},
				"id": 2844866488,
				"is_constexpr": true,
				"is_declaration": false,
				"is_definition": true,
				"kind": "variable",
				"name": "ROTATION_Z_90",
				"semantic_parent": {
					"name": "Mat4::",
					"objects": [{
						"_fullName": "::stappler::geom::Mat4",
						"_kind": "class",
						"_name": "Mat4",
						"attributes": [{
							"arguments": [{
								"kind": "int_literal",
								"spelling": "16"
							}],
							"is_variadic": false,
							"kind": "alignas_",
							"name": "alignas"
						}],
						"class_kind": "class",
						"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
						"id": 3473668624,
						"is_declaration": false,
						"is_definition": true,
						"is_final": false,
						"kind": "class",
						"name": "Mat4",
						"scope": {
							"name": "Mat4"
						},
						"semantic_scope": ""
					}]
				},
				"semantic_scope": "Mat4::",
				"type": {
					"_typeName": "stappler::geom::Mat4 const",
					"cv_qualifier": "const",
					"kind": "cv_qualified",
					"type": {
						"_typeName": "stappler::geom::Mat4",
						"kind": "user_defined",
						"target": {
							"name": "stappler::geom::Mat4",
							"objects": [{
								"_fullName": "::stappler::geom::Mat4",
								"_kind": "class",
								"_name": "Mat4",
								"attributes": [{
									"arguments": [{
										"kind": "int_literal",
										"spelling": "16"
									}],
									"is_variadic": false,
									"kind": "alignas_",
									"name": "alignas"
								}],
								"class_kind": "class",
								"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
								"id": 3473668624,
								"is_declaration": false,
								"is_definition": true,
								"is_final": false,
								"kind": "class",
								"name": "Mat4",
								"scope": {
									"name": "Mat4"
								},
								"semantic_scope": ""
							}]
						}
					}
				}
			}, {
				"_fullName": "::stappler::geom::Mat4::ROTATION_Z_180",
				"_kind": "variable",
				"_name": "ROTATION_Z_180",
				"default_value": {
					"expression": [{
						"kind": "identifier",
						"spelling": "Mat4"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "punctuation",
						"spelling": "-"
					}, {
						"kind": "float_literal",
						"spelling": "1.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "punctuation",
						"spelling": "-"
					}, {
						"kind": "float_literal",
						"spelling": "1.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "1.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "1.0f"
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}],
					"kind": "unexposed",
					"type": {
						"_typeName": "stappler::geom::Mat4 const",
						"cv_qualifier": "const",
						"kind": "cv_qualified",
						"type": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						}
					}
				},
				"id": 3298642523,
				"is_constexpr": true,
				"is_declaration": false,
				"is_definition": true,
				"kind": "variable",
				"name": "ROTATION_Z_180",
				"semantic_parent": {
					"name": "Mat4::",
					"objects": [{
						"_fullName": "::stappler::geom::Mat4",
						"_kind": "class",
						"_name": "Mat4",
						"attributes": [{
							"arguments": [{
								"kind": "int_literal",
								"spelling": "16"
							}],
							"is_variadic": false,
							"kind": "alignas_",
							"name": "alignas"
						}],
						"class_kind": "class",
						"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
						"id": 3473668624,
						"is_declaration": false,
						"is_definition": true,
						"is_final": false,
						"kind": "class",
						"name": "Mat4",
						"scope": {
							"name": "Mat4"
						},
						"semantic_scope": ""
					}]
				},
				"semantic_scope": "Mat4::",
				"type": {
					"_typeName": "stappler::geom::Mat4 const",
					"cv_qualifier": "const",
					"kind": "cv_qualified",
					"type": {
						"_typeName": "stappler::geom::Mat4",
						"kind": "user_defined",
						"target": {
							"name": "stappler::geom::Mat4",
							"objects": [{
								"_fullName": "::stappler::geom::Mat4",
								"_kind": "class",
								"_name": "Mat4",
								"attributes": [{
									"arguments": [{
										"kind": "int_literal",
										"spelling": "16"
									}],
									"is_variadic": false,
									"kind": "alignas_",
									"name": "alignas"
								}],
								"class_kind": "class",
								"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
								"id": 3473668624,
								"is_declaration": false,
								"is_definition": true,
								"is_final": false,
								"kind": "class",
								"name": "Mat4",
								"scope": {
									"name": "Mat4"
								},
								"semantic_scope": ""
							}]
						}
					}
				}
			}, {
				"_fullName": "::stappler::geom::Mat4::ROTATION_Z_270",
				"_kind": "variable",
				"_name": "ROTATION_Z_270",
				"default_value": {
					"expression": [{
						"kind": "identifier",
						"spelling": "Mat4"
					}, {
						"kind": "punctuation",
						"spelling": "("
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "1.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "punctuation",
						"spelling": "-"
					}, {
						"kind": "float_literal",
						"spelling": "1.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "1.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "0.0f"
					}, {
						"kind": "punctuation",
						"spelling": ","
					}, {
						"kind": "float_literal",
						"spelling": "1.0f"
					}, {
						"kind": "punctuation",
						"spelling": ")"
					}],
					"kind": "unexposed",
					"type": {
						"_typeName": "stappler::geom::Mat4 const",
						"cv_qualifier": "const",
						"kind": "cv_qualified",
						"type": {
							"_typeName": "stappler::geom::Mat4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Mat4",
								"objects": [{
									"_fullName": "::stappler::geom::Mat4",
									"_kind": "class",
									"_name": "Mat4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
									"id": 3473668624,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Mat4",
									"scope": {
										"name": "Mat4"
									},
									"semantic_scope": ""
								}]
							}
						}
					}
				},
				"id": 3684522809,
				"is_constexpr": true,
				"is_declaration": false,
				"is_definition": true,
				"kind": "variable",
				"name": "ROTATION_Z_270",
				"semantic_parent": {
					"name": "Mat4::",
					"objects": [{
						"_fullName": "::stappler::geom::Mat4",
						"_kind": "class",
						"_name": "Mat4",
						"attributes": [{
							"arguments": [{
								"kind": "int_literal",
								"spelling": "16"
							}],
							"is_variadic": false,
							"kind": "alignas_",
							"name": "alignas"
						}],
						"class_kind": "class",
						"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
						"id": 3473668624,
						"is_declaration": false,
						"is_definition": true,
						"is_final": false,
						"kind": "class",
						"name": "Mat4",
						"scope": {
							"name": "Mat4"
						},
						"semantic_scope": ""
					}]
				},
				"semantic_scope": "Mat4::",
				"type": {
					"_typeName": "stappler::geom::Mat4 const",
					"cv_qualifier": "const",
					"kind": "cv_qualified",
					"type": {
						"_typeName": "stappler::geom::Mat4",
						"kind": "user_defined",
						"target": {
							"name": "stappler::geom::Mat4",
							"objects": [{
								"_fullName": "::stappler::geom::Mat4",
								"_kind": "class",
								"_name": "Mat4",
								"attributes": [{
									"arguments": [{
										"kind": "int_literal",
										"spelling": "16"
									}],
									"is_variadic": false,
									"kind": "alignas_",
									"name": "alignas"
								}],
								"class_kind": "class",
								"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
								"id": 3473668624,
								"is_declaration": false,
								"is_definition": true,
								"is_final": false,
								"kind": "class",
								"name": "Mat4",
								"scope": {
									"name": "Mat4"
								},
								"semantic_scope": ""
							}]
						}
					}
				}
			}, {
				"_fullName": "::stappler::geom::operator*=(stappler::geom::Vec4&,stappler::geom::Mat4 const&)",
				"_kind": "function",
				"_name": "operator*=",
				"body_kind": "definition",
				"id": 4229987188,
				"is_consteval": false,
				"is_constexpr": false,
				"is_declaration": false,
				"is_definition": true,
				"is_variadic": false,
				"kind": "function",
				"name": "operator*=",
				"parameters": [{
					"_fullName": "v",
					"_kind": "function parameter",
					"_name": "v",
					"id": 1259630150,
					"kind": "function parameter",
					"name": "v",
					"type": {
						"_typeName": "stappler::geom::Vec4&",
						"kind": "reference",
						"referee": {
							"_typeName": "stappler::geom::Vec4",
							"kind": "user_defined",
							"target": {
								"name": "stappler::geom::Vec4",
								"objects": [{
									"_fullName": "::stappler::geom::Vec4",
									"_kind": "class",
									"_name": "Vec4",
									"attributes": [{
										"arguments": [{
											"kind": "int_literal",
											"spelling": "16"
										}],
										"is_variadic": false,
										"kind": "alignas_",
										"name": "alignas"
									}],
									"class_kind": "class",
									"id": 2114633745,
									"is_declaration": false,
									"is_definition": true,
									"is_final": false,
									"kind": "class",
									"name": "Vec4",
									"scope": {
										"name": "Vec4"
									},
									"semantic_scope": ""
								}]
							}
						},
						"reference_kind": "lvalue"
					}
				}, {
					"_fullName": "m",
					"_kind": "function parameter",
					"_name": "m",
					"id": 811278473,
					"kind": "function parameter",
					"name": "m",
					"type": {
						"_typeName": "stappler::geom::Mat4 const&",
						"kind": "reference",
						"referee": {
							"_typeName": "stappler::geom::Mat4 const",
							"cv_qualifier": "const",
							"kind": "cv_qualified",
							"type": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						},
						"reference_kind": "lvalue"
					}
				}],
				"return_type":  {
					"_typeName": "stappler::geom::Vec4&",
					"kind": "reference",
					"referee": {
						"_typeName": "stappler::geom::Vec4",
						"kind": "user_defined",
						"target": {
							"name": "stappler::geom::Vec4",
							"objects": [{
								"_fullName": "::stappler::geom::Vec4",
								"_kind": "class",
								"_name": "Vec4",
								"attributes": [{
									"arguments": [{
										"kind": "int_literal",
										"spelling": "16"
									}],
									"is_variadic": false,
									"kind": "alignas_",
									"name": "alignas"
								}],
								"class_kind": "class",
								"id": 2114633745,
								"is_declaration": false,
								"is_definition": true,
								"is_final": false,
								"kind": "class",
								"name": "Vec4",
								"scope": {
									"name": "Vec4"
								},
								"semantic_scope": ""
							}]
						}
					},
					"reference_kind": "lvalue"
				},
				"semantic_scope": "",
				"signature": "(stappler::geom::Vec4&,stappler::geom::Mat4 const&)"
			}, {
				"_fullName": "::stappler::geom::operator*(stappler::geom::Mat4 const&,stappler::geom::Vec4 const&)",
				"_kind": "function",
				"_name": "operator*",
				"body_kind": "definition",
				"id": 2043586982,
				"is_consteval": false,
				"is_constexpr": false,
				"is_declaration": false,
				"is_definition": true,
				"is_variadic": false,
				"kind": "function",
				"name": "operator*",
				"parameters": [{
					"_fullName": "m",
					"_kind": "function parameter",
					"_name": "m",
					"id": 811278473,
					"kind": "function parameter",
					"name": "m",
					"type": {
						"_typeName": "stappler::geom::Mat4 const&",
						"kind": "reference",
						"referee": {
							"_typeName": "stappler::geom::Mat4 const",
							"cv_qualifier": "const",
							"kind": "cv_qualified",
							"type": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						},
						"reference_kind": "lvalue"
					}
				}, {
					"_fullName": "v",
					"_kind": "function parameter",
					"_name": "v",
					"id": 1259630150,
					"kind": "function parameter",
					"name": "v",
					"type": {
						"_typeName": "stappler::geom::Vec4 const&",
						"kind": "reference",
						"referee": {
							"_typeName": "stappler::geom::Vec4 const",
							"cv_qualifier": "const",
							"kind": "cv_qualified",
							"type": {
								"_typeName": "stappler::geom::Vec4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec4",
									"objects": [{
										"_fullName": "::stappler::geom::Vec4",
										"_kind": "class",
										"_name": "Vec4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"id": 2114633745,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec4",
										"scope": {
											"name": "Vec4"
										},
										"semantic_scope": ""
									}]
								}
							}
						},
						"reference_kind": "lvalue"
					}
				}],
				"return_type":  {
					"_typeName": "stappler::geom::Vec4 const",
					"cv_qualifier": "const",
					"kind": "cv_qualified",
					"type": {
						"_typeName": "stappler::geom::Vec4",
						"kind": "user_defined",
						"target": {
							"name": "stappler::geom::Vec4",
							"objects": [{
								"_fullName": "::stappler::geom::Vec4",
								"_kind": "class",
								"_name": "Vec4",
								"attributes": [{
									"arguments": [{
										"kind": "int_literal",
										"spelling": "16"
									}],
									"is_variadic": false,
									"kind": "alignas_",
									"name": "alignas"
								}],
								"class_kind": "class",
								"id": 2114633745,
								"is_declaration": false,
								"is_definition": true,
								"is_final": false,
								"kind": "class",
								"name": "Vec4",
								"scope": {
									"name": "Vec4"
								},
								"semantic_scope": ""
							}]
						}
					}
				},
				"semantic_scope": "",
				"signature": "(stappler::geom::Mat4 const&,stappler::geom::Vec4 const&)"
			}, {
				"_fullName": "::stappler::geom::operator*(stappler::geom::Mat4 const&,stappler::geom::Vec3 const&)",
				"_kind": "function",
				"_name": "operator*",
				"body_kind": "definition",
				"id": 1919098400,
				"is_consteval": false,
				"is_constexpr": false,
				"is_declaration": false,
				"is_definition": true,
				"is_variadic": false,
				"kind": "function",
				"name": "operator*",
				"parameters": [{
					"_fullName": "m",
					"_kind": "function parameter",
					"_name": "m",
					"id": 811278473,
					"kind": "function parameter",
					"name": "m",
					"type": {
						"_typeName": "stappler::geom::Mat4 const&",
						"kind": "reference",
						"referee": {
							"_typeName": "stappler::geom::Mat4 const",
							"cv_qualifier": "const",
							"kind": "cv_qualified",
							"type": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						},
						"reference_kind": "lvalue"
					}
				}, {
					"_fullName": "v",
					"_kind": "function parameter",
					"_name": "v",
					"id": 1259630150,
					"kind": "function parameter",
					"name": "v",
					"type": {
						"_typeName": "stappler::geom::Vec3 const&",
						"kind": "reference",
						"referee": {
							"_typeName": "stappler::geom::Vec3 const",
							"cv_qualifier": "const",
							"kind": "cv_qualified",
							"type": {
								"_typeName": "stappler::geom::Vec3",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec3",
									"objects": [{
										"_fullName": "::stappler::geom::Vec3",
										"_kind": "class",
										"_name": "Vec3",
										"class_kind": "class",
										"id": 748569271,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec3",
										"scope": {
											"name": "Vec3"
										},
										"semantic_scope": ""
									}]
								}
							}
						},
						"reference_kind": "lvalue"
					}
				}],
				"return_type":  {
					"_typeName": "stappler::geom::Vec3 const",
					"cv_qualifier": "const",
					"kind": "cv_qualified",
					"type": {
						"_typeName": "stappler::geom::Vec3",
						"kind": "user_defined",
						"target": {
							"name": "stappler::geom::Vec3",
							"objects": [{
								"_fullName": "::stappler::geom::Vec3",
								"_kind": "class",
								"_name": "Vec3",
								"class_kind": "class",
								"id": 748569271,
								"is_declaration": false,
								"is_definition": true,
								"is_final": false,
								"kind": "class",
								"name": "Vec3",
								"scope": {
									"name": "Vec3"
								},
								"semantic_scope": ""
							}]
						}
					}
				},
				"semantic_scope": "",
				"signature": "(stappler::geom::Mat4 const&,stappler::geom::Vec3 const&)"
			}, {
				"_fullName": "::stappler::geom::operator*(stappler::geom::Mat4 const&,stappler::geom::Vec2 const&)",
				"_kind": "function",
				"_name": "operator*",
				"body_kind": "definition",
				"id": 2418894364,
				"is_consteval": false,
				"is_constexpr": false,
				"is_declaration": false,
				"is_definition": true,
				"is_variadic": false,
				"kind": "function",
				"name": "operator*",
				"parameters": [{
					"_fullName": "m",
					"_kind": "function parameter",
					"_name": "m",
					"id": 811278473,
					"kind": "function parameter",
					"name": "m",
					"type": {
						"_typeName": "stappler::geom::Mat4 const&",
						"kind": "reference",
						"referee": {
							"_typeName": "stappler::geom::Mat4 const",
							"cv_qualifier": "const",
							"kind": "cv_qualified",
							"type": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						},
						"reference_kind": "lvalue"
					}
				}, {
					"_fullName": "v",
					"_kind": "function parameter",
					"_name": "v",
					"id": 1259630150,
					"kind": "function parameter",
					"name": "v",
					"type": {
						"_typeName": "stappler::geom::Vec2 const&",
						"kind": "reference",
						"referee": {
							"_typeName": "stappler::geom::Vec2 const",
							"cv_qualifier": "const",
							"kind": "cv_qualified",
							"type": {
								"_typeName": "stappler::geom::Vec2",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Vec2",
									"objects": [{
										"_fullName": "::stappler::geom::Vec2",
										"_kind": "class",
										"_name": "Vec2",
										"class_kind": "class",
										"id": 16661423,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Vec2",
										"scope": {
											"name": "Vec2"
										},
										"semantic_scope": ""
									}]
								}
							}
						},
						"reference_kind": "lvalue"
					}
				}],
				"return_type":  {
					"_typeName": "stappler::geom::Vec2 const",
					"cv_qualifier": "const",
					"kind": "cv_qualified",
					"type": {
						"_typeName": "stappler::geom::Vec2",
						"kind": "user_defined",
						"target": {
							"name": "stappler::geom::Vec2",
							"objects": [{
								"_fullName": "::stappler::geom::Vec2",
								"_kind": "class",
								"_name": "Vec2",
								"class_kind": "class",
								"id": 16661423,
								"is_declaration": false,
								"is_definition": true,
								"is_final": false,
								"kind": "class",
								"name": "Vec2",
								"scope": {
									"name": "Vec2"
								},
								"semantic_scope": ""
							}]
						}
					}
				},
				"semantic_scope": "",
				"signature": "(stappler::geom::Mat4 const&,stappler::geom::Vec2 const&)"
			}, {
				"_fullName": "::stappler::geom::operator<<(std::basic_ostream<char>&,stappler::geom::Mat4 const&)",
				"_kind": "function",
				"_name": "operator<<",
				"body_kind": "definition",
				"id": 3622044424,
				"is_consteval": false,
				"is_constexpr": false,
				"is_declaration": false,
				"is_definition": true,
				"is_variadic": false,
				"kind": "function",
				"name": "operator<<",
				"parameters": [{
					"_fullName": "os",
					"_kind": "function parameter",
					"_name": "os",
					"id": 85735794,
					"kind": "function parameter",
					"name": "os",
					"type": {
						"_typeName": "std::basic_ostream<char>&",
						"kind": "reference",
						"referee": {
							"_typeName": "std::basic_ostream<char>",
							"arguments_exposed": false,
							"kind": "template_instantiation",
							"primary_template": {
								"name": "std::basic_ostream"
							},
							"unexposed_arguments": "char"
						},
						"reference_kind": "lvalue"
					}
				}, {
					"_fullName": "m",
					"_kind": "function parameter",
					"_name": "m",
					"id": 811278473,
					"kind": "function parameter",
					"name": "m",
					"type": {
						"_typeName": "stappler::geom::Mat4 const&",
						"kind": "reference",
						"referee": {
							"_typeName": "stappler::geom::Mat4 const",
							"cv_qualifier": "const",
							"kind": "cv_qualified",
							"type": {
								"_typeName": "stappler::geom::Mat4",
								"kind": "user_defined",
								"target": {
									"name": "stappler::geom::Mat4",
									"objects": [{
										"_fullName": "::stappler::geom::Mat4",
										"_kind": "class",
										"_name": "Mat4",
										"attributes": [{
											"arguments": [{
												"kind": "int_literal",
												"spelling": "16"
											}],
											"is_variadic": false,
											"kind": "alignas_",
											"name": "alignas"
										}],
										"class_kind": "class",
										"comment": "\nDefines a 4 x 4 floating point matrix representing a 3D transformation.\n\nVectors are treated as columns, resulting in a matrix that is represented as follows,\nwhere x, y and z are the translation components of the matrix:\n\n    1  0  0  x\n    0  1  0  y\n    0  0  1  z\n    0  0  0  1\n\nThis matrix class is directly compatible with OpenGL since its elements are\nlaid out in memory exactly as they are expected by OpenGL.\nThe matrix uses column-major format such that array indices increase down column first.\nSince matrix multiplication is not commutative, multiplication must be done in the\ncorrect order when combining transformations. Suppose we have a translation\nmatrix T and a rotation matrix R. To first rotate an object around the origin\nand then translate it, you would multiply the two matrices as TR.\n\nLikewise, to first translate the object and then rotate it, you would do RT.\nSo generally, matrices must be multiplied in the reverse order in which you\nwant the transformations to take place (this also applies to\nthe scale, rotate, and translate methods below; these methods are convenience\nmethods for post-multiplying by a matrix representing a scale, rotation, or translation).\n\nIn the case of repeated local transformations (i.e. rotate around the Z-axis by 0.76 radians,\nthen translate by 2.1 along the X-axis, then ...), it is better to use the Transform class\n(which is optimized for that kind of usage).\n\n@see Transform\n",
										"id": 3473668624,
										"is_declaration": false,
										"is_definition": true,
										"is_final": false,
										"kind": "class",
										"name": "Mat4",
										"scope": {
											"name": "Mat4"
										},
										"semantic_scope": ""
									}]
								}
							}
						},
						"reference_kind": "lvalue"
					}
				}],
				"return_type":  {
					"_typeName": "std::basic_ostream<char>&",
					"kind": "reference",
					"referee": {
						"_typeName": "std::basic_ostream<char>",
						"arguments_exposed": false,
						"kind": "template_instantiation",
						"primary_template": {
							"name": "std::basic_ostream"
						},
						"unexposed_arguments": "char"
					},
					"reference_kind": "lvalue"
				},
				"semantic_scope": "",
				"signature": "(std::basic_ostream<char>&,stappler::geom::Mat4 const&)"
			}],
			"id": 2654716457,
			"is_anonymous": false,
			"is_inline": false,
			"is_nested": true,
			"kind": "namespace",
			"name": "geom",
			"scope": {
				"name": "geom"
			}
		}],
		"id": 96045446,
		"is_anonymous": false,
		"is_inline": false,
		"is_nested": false,
		"kind": "namespace",
		"name": "stappler",
		"scope": {
			"name": "stappler"
		}
	}],
	"id": 348657058,
	"kind": "file",
	"name": "core/geom/SPMat4.h",
	"unmatched_comments": [{
		"line": 23,
		"text": "\nCopyright 2013 BlackBerry Inc.\nCopyright (c) 2014-2015 Chukong Technologies\nCopyright (c) 2017-2019 Roman Katuntsev <sbkarr@stappler.org>\nCopyright (c) 2023 Stappler LLC <admin@stappler.dev>\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nOriginal file from GamePlay3D: http://gameplay3d.org\n\nThis file was modified to fit the cocos2d-x project\nThis file was modified for stappler project\n"
	}]
}