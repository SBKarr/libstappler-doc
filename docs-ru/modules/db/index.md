Title: Базы данных

# Базы данных

Модуль базы данных `stappler_db`.

Система поддерживает доступ к СУБД [PostgreSQL](postgres.md) и [SQLite](sqlite.md).

Все системы работы с БД используют интерфейс пулов памяти.

## Интерфейс приложения

Для работы с БД необходимо определить интерфейс приложения. Для простых приложений можно использовать тип `db::SimpleServer` (`SPDbSimpleServer.h`). Для более сложных взаимодействий необходимо перегружать класс `db::ApplicationInterface` (`SPDbAdapter.h`) вручную или использовать встроенные в подсистему механизмы (ресурсный модуль `xenolith_resource_storage`, компоненты для веб-сервера).

## Схемы данных

Интерфейс БД основан на схемах данных. Пример определения схемы:

```cpp
#include "SPScheme.h"

using namespace stappler::db;

Scheme _objects;

_objects.define(Vector<Field>{
	Field::Text("text", MinLength(3), Flags::Indexed),
	Field::Extra("data", Vector<Field>{
		Field::Array("strings", Field::Text("")),
	}),
	Field::Set("subobjects", _subobjects),
	Field::File("file", MaxFileSize(1_MiB)),
	Field::Text("alias", Transform::Alias),
	Field::Integer("mtime", Flags::AutoMTime | Flags::Indexed),
	Field::Integer("index", Flags::Indexed),
	Field::View("refs", _refs, ViewFn([this] (const Scheme &objScheme, const Value &obj) -> bool {
		return true;
	}), FieldView::Delta),

	Field::Array("array", Field::Extra("", Vector<Field>{
		Field::Integer("one"),
		Field::Integer("two"),
	})),

	Field::Extra("textFile", Vector<Field>{
		Field::Text("type"),
		Field::Integer("mtime"),
		Field::Text("content"),
	}),
	Field::Extra("binaryFile", Vector<Field>{
		Field::Text("type"),
		Field::Integer("mtime"),
		Field::Bytes("content"),
	}),

	Field::Set("images", _images, Flags::Composed),
},
AccessRole::Admin(AccessRoleId::Authorized));
```

Тип `Field` предназначен для определения полей схемы. Доступные типы полей:

* `Data` - нетипизированные данные
* `Integer` - целое число
* `Float` - число с плавающей точкой
* `Boolean` - логический тип
* `Text` - текст
* `Bytes` - бинарные данные
* `Password` - специальный тип для хранения паролей
* `Extra` - нетипизированные данные, следующие определённой схеме
* `File` - внешний файл
* `Image` - внешнее изображение
* `Object` - связь с объектом другой схемы
* `Set` - связь с набором объектов другой схемы
* `Array` - массив из других полей
* `View` - отображение другой схемы с возможностью фильтрации
* `FullTextView` - полнотекстовое отображение, используется для полнотекстового поиска
* `Virtual` - виртуальное (вычислимое) поле. Вызывает определённые функции чтения и записи при доступе к полю
* `Custom` - поле с пользовательским определением (примеры в `SPDbFieldExtensions.h`)

Режим работы полей модифицируется флагами (`db::Flags`), трансформациями (`db::Transform`), фильтрующими функциями (`db::ReadFilterFn, db::WriteFilterFn, db::ReplaceFilterFn`), специализированными параметрами конфигурации (см. `SPDbField.h`). Все моификаторы передаются в произвольном порядке в конструктор поля.

Для запроса к данным необходимо получить доступ к транзакции БД. Способ получения зависит от реализации `ApplicationInterface`.

В схеме всегда определено поле `__oid` типа `Integer`, представляющее внутренний уникальный идентификатор. Как правило, оно уникально внутри системы в целом (за исключением схем с флагом `Scheme::Detached`).

После получения можно выполнять запросы к данным с помощью функций `Scheme`:

```cpp
class Scheme {
public:
	// описание основных прототипов, полный список вариантов в SPDbWorker.h в классе Worker.
	// В реальном коде функции ретранслируются в класс Worker, и проверка прототипа выполняется там

	auto get(const Transaction &&, int64_t, UpdateFlags) const -> Value;
	auto foreach(const Transaction &t, const Query &,
			const Callback<bool(Value &)> &) const -> bool;
	auto select(const Transaction &t, const Query &) const -> Value;
	auto create(const Transaction &t, const Value &, UpdateFlags) const -> Value;
	auto update(const Transaction &t, int64_t, const Value &, UpdateFlags) const  -> Value;
	auto remove(const Transaction &t, int64_t) const -> bool;
	auto count(const Transaction &t, const Query &) const -> size_t;
	auto touch(const Transaction &t, int64_t) const -> void;

	auto getProperty(const Transaction &t, int64_t, StringView field) const -> Value;
	auto setProperty(const Transaction &t, int64_t, StringView field, const Value &) const -> Value;
	auto appendProperty(const Transaction &t, int64_t, StringView field, const Value &) const -> Value;
	auto clearProperty(const Transaction &t, int64_t, StringView field) const -> bool;
	auto countProperty(const Transaction &t, int64_t, StringView field) const -> size_t;
};
```

Функции доступа к свойствам работают на конкретное поле объекта, это поле должно относиться к типам `File, Image, Object, Set, Array`.

## Тип запроса

Тип `db::Query` предназначен для выполнения запросов к БД.

```cpp
#include "SPDbQuery.h"

namespace stappler::db {

class Query : public AllocBase {
public:
	// Тип поля для включения или исключения
	struct Field : public AllocBase {
		String name;
		Vector<Field> fields;
	};

	// Тип для хранения ограничения запроса
	struct Select : public AllocBase {
		Comparation compare = Comparation::Equal;
		Value value1;
		Value value2;
		String field;
		FullTextQuery textQuery;
	};

	static Query all(); // запрос ко всем объектам схемы
	static Query field(int64_t id, const StringView &); // запрос к полю конкретного объекта
	static Query field(int64_t id, const StringView &, const Query &); // запрос к полю конкретного объекта

	Query & select(const StringView &alias); // запрос по псевдониму
	Query & select(int64_t id); // запрос по __oid
	Query & select(const Value &); // запрос по псевдониму, __oid или уже полученному объекту
	Query & select(Vector<int64_t> &&id); // запрос списка объектов по __oid

	// ограничение запроса
	Query & select(const StringView &f, Comparation c, const Value & v1, const Value &v2 = Value());
	Query & select(const StringView &f, const Value & v1); // специальный случай для точного соотвествия
	Query & select(const StringView &f, FullTextQuery && v);
	Query & select(Select &&q);

	// упорядочивание результата
	Query & order(const StringView &f, Ordering o = Ordering::Ascending, size_t limit = stappler::maxOf<size_t>(), size_t offset = 0);
	
	// запрос по мягкому лимиту (ContinueToken)
	Query & softLimit(const StringView &, Ordering, size_t limit, Value &&);
	Query & first(const StringView &f, size_t limit = 1, size_t offset = 0);
	Query & last(const StringView &f, size_t limit = 1, size_t offset = 0);

	// запрос по страничному лимиту
	Query & limit(size_t l, size_t off);
	Query & limit(size_t l);
	Query & offset(size_t l);

	// дельта-запрос
	Query & delta(uint64_t);
	Query & delta(const StringView &);

	// включить поля в запрос
	template <typename ... Args>
	Query & include(Field &&, Args && ...);

	Query & include(Field &&);
	
	// Исключить поле из запроса
	Query & exclude(Field &&);

	// Блокирует объект при получении до обновления
	Query & forUpdate();
};

}
```

## Путь прохождения запроса

* Создаётся объект `Worker` (`SPDbWorker.h`), соответствующий текущему запросу. Данный объект интерпретирует аргументы запроса и конвертирует их в удобное для системы внутреннее представление (например, запрос `get` конвертируется в `select`). Также, `Worker` создаёт или захватывает текущую активную транзакцию (`Transaction`: `SPDbTransaction.h`). 
* Созданный `Worker` передаётся назад в `Scheme`, вызывая соответствующую конкретную реализацию запроса (например, `updateWithWorker`, `SPDbScheme.cc:523`). Эта функция производит фильтрацию и адаптацию входящих данных, добавляет автоматические значения, значения по умолчанию. Эта функция может выйти с ошибкой если переданные данные не могут использоваться для запроса на основании описания полей (например, не определено требуемое поле). Также, проводится дополнительный анализ, например, выбор между стратегиями `patch` (разовый запрос на обновление в БД) и `update` (запрос, работающий по парадигме чтение-модификация-запись).
* Данные запроса и `Worker` передаются в `Transaction` с соответствующим запросом. Транзакция выполняет проверку уровня доступа для запроса и может завершить запрос, если проверка не проходит. Проверка уровня доступа также может модифицировать запрос, добавляя параметры. В ходе проверки уровня доступа могут выполняться дополнительные запросы к БД, такие запросы активно кешируются в транзакции.
* Транзакция передаёт запрос и `Worker` в `Adapter` (`SPDbAdapter.h`). Адаптер реализует функции виртуальных полей, контролирует другие вычислимые поля, такие, как `View`. На момент получения адаптером запроса можно быть уверенным, что запрос корректен с позиции схемы данных и контроля доступа, а значит, его выполнение ограничено лишь технической реализацией доступа к БД.
* Адаптер передаёт запрос непосредственно в интерфейс к БД, связанный с транзакцией, на исполнение. Этот интерфейс реализует непосредственно преобразование логического представления запроса в соответствующий текст SQL либо функции БД.
* Успешно полученный результат проходит через `Adapter`. Выполняются функции, контролирующие работу автоматических полей, если необходима модификация объектов других схем данных.
* Результат из адаптера возвращается в транзакцию. Выполняется фильтрация результата на основании контроля доступа.
* Результат возвращается в схему данных. На этом этапе выполняются функции преобразования выходных данных в их конечное представление.
* Результат возвращается пользователю.
В некоторых случаях удобно создать объект `Worker` вручную. Например, для определения текущего запроса как системного на уровне контроля доступа либо при наличии нескольких активных транзакций.

## Автоматичизация полей

### Значения по умолчанию

Значение по умолчанию можно задать двумя способами:
* Статически, передав `Value` в определение поля
* Динамически, передав `db::DefaultFn`. В функцию будут передаваться данные, с которыми создаётся объект.
* Неявно, с помощью флагов `Flags::AutoCTime, Flags::AutoMTime`

### Фильтрация

Фильтры позводяют изменить значение, которое будет сохранено в БД или выведено пользователю. Фильтры работают снаружи от контроля доступа.

* `ReadFilterFn = Function<bool(const Scheme &, const Value &obj, Value &value)>` - изменяет значение, которое будет возвращено пользователю на основании полученного из БД. При необходимости изме6нить значение, изменяется value. Чтобы скрыть значение, необходимо вернуть false.
* `WriteFilterFn = Function<bool(const Scheme &, const Value &patch, Value &value, bool isCreate)>` - изменяет значение для записи в БД на основании переданного пользователем. Для запрета записи нужно вернуть false.
* `ReplaceFilterFn = Function<bool(const Scheme &, const Value &obj, const Value &oldValue, Value &newValue)>` - вариант `WriteFilterFn`с доступом предыдущему значению поля. Работает медленнее.

### Вычислимые и виртуальные поля

Для вычислимых и виртуальных полей используется тип `Virtual`. Пример реализации:

```cpp

_virtualTest.define({
	Field::Text("name", MinLength(3)),
	Field::Virtual("computed", VirtualReadFn([] (const Scheme &, const Value &value) {
		Value tmp(value);
		tmp.erase("__oid");
		tmp.setInteger(Time::now().toMicros(), "time");
		return tmp;
	}), Vector<String>({"name"})),

	Field::Virtual("virtual", VirtualReadFn([] (const Scheme &, const Value &value) {
		auto path = filesystem::writablePath<Interface>(toString(value.getString("name"), ".cbor"));
		if (filesystem::exists(path)) {
			return data::readFile<Interface>(path);
		}
		return Value();
	}), VirtualWriteFn([] (const Scheme &objScheme, const Value &obj, Value &data) {
		auto path = filesystem::writablePath<Interface>(toString(obj.getString("name"), ".cbor"));
		data::save<Interface>(data, path);
		return true;
	}), Vector<String>({"name"}))
});
```

Виртуальные поля определяют, какие реальные поля необходимы для их работы в виде массивов имён. Гарантируется, что значение этих полей будет доступно в функциях `VirtualReadFn` и `VirtualWriteFn`.

## Связи между полями

Пример:

```cpp
_hierarchy.define(Vector<Field>({
	Field::Text("name", MinLength(3)),
	Field::Integer("id", Flags::Indexed),
	Field::Object("root", _hierarchy, Linkage::Manual, ForeignLink("sections")),
	Field::Set("sections", _hierarchy, Linkage::Manual, ForeignLink("root")),
	Field::Set("all_pages", _pages)
}));
```

База данных предполагает, что схемы данных будут связаны друг с другом и взаимно контролироваться. Это реализовано с помощью полей типа Object и Set.

По силе связи, их можно разделить на:
* Сильные: `RemovePolicy::Cascade`, `RemovePolicy::Restrict` - объект может существовать и быть удалён только вместе с другим объектом. Оба объекта имеют какого-то вида ссылки друг на друга (двусторонняя связь).
* Слабые: `RemovePolicy::Null` - объект может существовать отдельно от связи, в случае удаления связь обнуляется. Связь двусторонняя.
* Внешние сильные - односторонняя связь, при которой удаление связанного объекта ведёт к удалению связанных с ним (`RemovePolicy::StrongReference`).
* Внешние слабые - односторонняя связь, при которой удаление объекта ничего не меняет (`RemovePolicy::Reference`).
По отношению, связи можно разделить на:
* один к одному (поля `Object`),
* один ко многим (связанные поля `Object` и `Set`, поле `Set` c внешними ссылками),
* многие ко многим.

Мы не рекомендуем использовать последний вид связи (многие ко многим) и не реализуем такую связь автоматически (но пользователь сам может реализовать её через промежуточную таблицу), поскольку это ведёт к множеству ошибок. Чаще всего, такую связь имеет смысл заменить отражениями (`View`) или другими высокоуровневыми подходами.

Для простых связей SDK находит связанные поля автоматически по взаимным ссылкам на схемы, однако, это невозможно, когда ссылка ведёт на свою же схему. В таком случае, ссылки можно определить явно по имени поля в целевой схеме.

За способ реализации связей отвечает непосредственно интерфейс БД. Для PostgreSQL они реализуются с помощью внешних ключей, и, в некоторых случаях (например, для внешней сильной связи), с помощью дополнительных таблиц и триггеров.

## Связи высокого уровня

```cpp
_auto.define(Vector<Field>({
	Field::View("pages", _pages, ViewFn([] (const Scheme &, const Value &obj) -> bool {
		return obj.getBool("hidden") ? false : true;
	}), Vector<String>({ "hidden" })),

	Field::Text("data", AutoFieldDef{
		Vector<AutoFieldScheme>({
			AutoFieldScheme{ _auto, {"text", "key"} }
		}),
		DefaultFn([this] (const Value &data) -> Value {
			// content generation
		}),
		Vector<String>({"text", "key"}),
	}),
}));
```

В ряде случаев стандартной связи полей недостаточно, необходимо наложить на эту связь некие условия, либо связать объекты нестандартным способом. Для таких случаев предназначены связи высокого уровня: отражения (`View`) и автоматические поля связей (`AutoFieldDef`).

Ключевой момент для этих полей - возможность установить связь. Для случая отражения, это может быть сделано автоматически, по аналогии с полем типов `Set` или `Object`. Однако, в общем случае это невозможно, потому необходима функция линковки (`ViewLinkageFn`). Эта функция, вызванная для объекта подчинённой схемы, должна определить идентификатор основной схемы. Функция вызывается, когда отражение или автоматическое поле должно быть обновлено.

Далее, автоматические поля и отражения действуют различным образом.

Отражение является списком объектов другой схемы, связанным с текущим объектом по некоторому условию. Это условие определяется параметром-функцией ViewFn. SDK проверяет, соответствует ли объект условию после того, как схема получила результат модифицирующего запроса. Пользователь может обозначить список полей, требуемых для этой функции, аналогично тому, как это делается для несвязных автоматических полей. Если состояние соответствия объекта изменилось, то есть, объект стал соответствовать или перестал соответствовать отражению, об этом информируется адаптер и операция на обновление отражения добавляется в асинхронную очередь.

Автоматическое связанное поле — это поле, имеющее свой характерный тип (не выделенный тип, как `View`), однако, вычисляется автоматически в зависимости от значений других объектов. Для того, чтобы оно было обновлено, система должна обновить одно из указанных в списке `requiresForAuto` полей.

## Контроль доступа

Контроль доступа в интерфейсе БД реализован на уровне транзакции. Таким образом, все пользовательские данные запроса проходят фильтрацию и модификацию до прихода в транзакцию, затем - проверяются функциями контроля доступа для входящих данных. После получения ответа, он фильтруется функциями контроля доступа исходящих данных. Прохождение запроса между этими двумя стадиями мы называем “безопасным режимом”.

Контроль доступа на уровне приложения предназначен в первую очередь для того, чтобы разработчик с большей вероятностью писал код, не оставляющий прямых лазеек для злоумышленника и сразу задумывался о полномочиях пользователей.

Контроль доступа определяется на уровне логики доступа определённого класса пользователей к схеме данных. Для каждой операции существуют классы разрешений (`SPDbTransaction.h`), для выполнения операции у класса пользователей должно быть на неё разрешение:
* `Id` - возможность идентифицировать объект схемы, получить его __oid
* `Select` - возможность получить данные объекта схемы
* `Count` - возможность посчитать количество объектов схемы
* `Remove` - возможность удалять объекты схемы
* `Create` - возможность создавать объекты схемы
* `Save` - возможность модифицировать объекты при помощи механизма - чтение-модификация-запись
* `Patch` - возможность модифицировать объекты схемы единичным запросом
* `FieldGet` - возможность получать сложные поля объекта схемы (не касается возможности получения самих объектов, это определяется непосредственно в их схеме)
* `FieldSet` - возможность изменять сложные поля объекта схемы
* `FieldAppend` - возможность добавлять объекты к полю
* `FieldClear` - возможность очищать поле
* `FieldCount` - возможность подсчитать число объектов в поле
* `Delta` - возможность выполнять дельта-запросы на схему
* `DeltaView` - возможность выполнять дельта-запросы на поле View в схеме
* `RemoveFromView` - возможность удалять объекты из отражения
* `AddToView` - возможность добавлять объекты к отражению

Помимо разрешения на операцию, определяются также функции, способные модифицировать или отклонить ряд операций (`SPDbTransaction.h`):
* `OnSelect` - при попытке получить объекты
* `OnCount` - при подсчёте объектов
* `OnCreate` - при создании объектов
* `OnPatch` - при модификации объекта
* `OnSave` - при перезаписи объекта
* `OnRemove` - при удалении объекта
* `OnField` - при операции над полем объекта

Две функции определяют выходную фильтрацию данных на уровне контроля доступа:
* `OnReturn` - при возврате объекта
* `OnReturnField` - при возврате поля объекта

Флаги операций и определяющие функции формируют структуру пользовательского доступа (`AccessRole`), которая назначается для одной из ролей в таблице (на текущий момент, не более 14 ролей на схему). Выделены две специальные роли:
* `System`: роль, полномочия которой всегда абсолютны, невозможно переопределить доступ
* `Default`: роль, правила которой всегда применяются для всех кроме `System`.

Также, три именованных роли предназначены для удобства разработчика и не имеют специального определения:
* `Nobody` - неизвестный пользователь
* `Authorized` - известный пользователь
* `Admin` - администратор системы (не имеет абсолютных полномочий по умолчанию)

Текущая роль пользователя определяется при начале транзакции. Разработчик может добавить свою собственную логику определения текущей роли пользователя при реализации сервера БД внутри приложения, переопределив функцию `onStorageTransaction` базового объекта
.
Иногда для приложения требуется обойти систему безопасности и повысить текущие полномочия. Таких способов три:
* Функция `Transaction::performAsSystem` повышает полномочия до системных при вызове переданного функтора.
* Функция `Worker::asSystem` повышает полномочия связанной с рабочим объектом операции до системных. Для этого требуется создать собственный объект `Worker`.
* Прямой доступ к интерфейсу БД (`Adapter::getBackendInterface`) и ручное исполнение запросов на нём в обход пути запроса SDK. Крайне небезопасный метод, но может быть необходим для реализации специфических функций поверх конкретной СУБД.

Во всех остальных случаях система контроля доступа будет активна. Таким образом, соблюдён общий принцип - чтобы сделать нечто небезопасное, это нужно явно обозначить.

## Мягкий лимит и ContinueToken

Система `ContinueToken` (`SPDbContinueToken.h`) обеспечивает такую итерацию.

Базовая идея построена на использовании опорного значения по определённому полю, чтобы от него отсчитывать текущую страницу. Для неуникальных полей такая страница может иметь больше элемментов, чем необходимо, что и делает такой лимит мягким. Такая система всегда имеет линейную производительность.

Пример перебора значений с использованием `ContinueToken`:

```cpp
StringView c;
auto orig = mem::pool::acquire();
auto p = mem::pool::create(orig);
bool ended = false;
size_t batch = 20000; // размер пакета для обработки

while (!ended) {
    if (auto t = db::Transaction::acquire()) {
   	 mem::perform([&] { // экономим память через операционный пул
   		 // здесь id - вторичный уникальный индекс
   		 auto token = c.empty() ? ContinueToken("id", batch, false) : ContinueToken(c);

   		 db::Query q;
   		 auto data = token.perform(_trades, t, q);

   		 ...

   		 if (token.getNumResults() < token.getCount()) {
   			 ended = true;
   		 } else {
   			 c = StringView(token.encodeNext()).pdup(orig);
   		 }
   	 }, p);
    }
    mem::pool::clear(p);
}
```

Под капотом используются функции `Query::softLimit`.

## Прочие функции

Сжатие на ходу работает для полей типа `Data` и `Extra` с заданным флагом `Flags::Compressed`.

Для поддержки дельта-запросов на уровне схемы необходимо явно указывать флаг `Scheme::WithDelta`. На уровне отображения `FieldView::Delta`. После этого дельта-запросы будут доступны через тип `Query`.

`Adapter` реализует функции хранилища ключ-значение:
* `get` - получает значение по ключу
* `set` - устанавливает значение для ключа
* `clear` - удаляет значение для ключа
Ключом могут выступать любые бинарные данные (что удобно при использовании хешей), и по умолчанию ни одно значение не хранится вечно.