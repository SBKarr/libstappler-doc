Title: Cтиль кода и внесение изменений

# Внесение изменений и стиль кода

## Структура модулей

Модули реализуют некую функциональную возможность, выраженную в виде существительного в их названии: `filesystem`, `bitmap`, `crypto`. Название модуля записывается в строчном регистре со знаком “_” в качестве разделителя. Этот разделитель также ставится вместо разделителя пути.

Имя модуля начинается с названия проекта, после чего указывается его путь внутри проекта, и, в конце, его собственное название: `stappler` (проект) `_ crypto` (название), `xenolith` (проект) `_resources` (путь) `_assets` (название).

Файл определения модуля должен иметь имя этого модуля и располагаться в директории этого модуля: `/xenolith/core/core.mk`. Для модулей, не определяющих исходных кодов (библиотечные модули, например, `stappler_backtrace`) определение модуля располагается в директории проекта (`stappler/backtrace.mk`).

При включении модуля в сборку, SDK определяет соответствующий ему символ при компиляции. Для `stappler_crypto`: `MODULE_STAPPLER_CRYPTO`. Для `xenolith_resources_assets`: `MODULE_XENOLITH_RESOURCES_ASSETS`.

Для поиска модуля в системе создаётся определение вида:

```make
MODULE_xenolith_scene := MODULE_XENOLITH_SCENE
```

Далее, `MODULE_XENOLITH_SCENE` используется в качестве префикса к определению переменных модуля.

Рекомендуется максимально возможно уменьшать глубину вложенности файлов исходного кода внутри модуля, однако, относиться к этому правилу разумно и не держать разнородный исходный код в одной директории. Для вложенности внутри проекта допускается 1-2 уровня, и желательно не более одного уровня вложенности внутри модуля.

Специальный случай вложенности - платформозависимые и другие заменяемые файлы. В таком случае, допускается структура директорий внутри модуля вида:

* (module_dir)/platform/linux
* (module_dir)/platform/android
* (module_dir)/platform/win32

Модули группируются в проекты, для доступа к модулям проекта используется файл-реестр, определяющий пути до определения модулей, он носит имя (имя_проекта)-modules.mk и располагается в корне проекта. Этот файл также определяет версию проекта.

```make
STAPPLER_MODULE_DIR := $(abspath $(dir $(lastword $(MAKEFILE_LIST))))

# Включение файлов модулей
include $(STAPPLER_MODULE_DIR)/core/core.mk
include $(STAPPLER_MODULE_DIR)/bitmap/bitmap.mk

```

## Структура файлов исходного кода модуля

Файлы исходного кода называются следующим образом: `SPFontHyphenMap.cc`. `SPCrypto-mbedtls.cc`. `SPDbConfig.h`.

Структура названия:
* Префикс проекта: `SP`, `XL`, `Material`
* Префикс модуля: `Font`, `Crypto`, `Db`
* Функциональное имя: `HyphenMap`, `Config` (может быть опущено, если в модуле нет иных функциональных файлов или для основного файла модуля)
* Вариант (реализует вариант функциональности для конкретной платформы/бэкэнда): `-mbedtls`, `-linux`, `-android`.
* Расширение
  * `.h` - заголовочные файлы
  * `.hpp` - включаемые заголовочные файлы, могут включаться в другой заголовок модуля и не должны включаться за пределами модуля
  * `.c`, `.cpp` - одиночные компилируемые файлы
  * `.scu.c`, `.scu.cpp` - файлы SCU
  * `.сс` - файлы, включаемые в SCU
  * `.wit` - файлы описания интерфейса WebAssembly
  * `.comp`, `.frag`, `.vert`, `.geom` и другие - файлы шейдеров GLSL.

Для определения файлов модуля используется схема:

```make
# директории для автоматического поиска исходных файлов
MODULE_XENOLITH_SCENE_SRCS_DIRS := $(XENOLITH_MODULE_DIR)/scene
# перечисление отдельных исходных файлов
# сюда также могут включаться файлы .wit интерфейсов WASM.
MODULE_XENOLITH_SCENE_SRCS_OBJS :=
```

Для файлов исходного кода, SDK использует подход SCU, что значительно ускоряет компиляцию на современных системах за счёт большего расхода памяти. Файлы SCU должны иметь соответствующее расширение. Условная граница объёма файла SCU - 7500 строк кода без учёта заголовков, при превышении размера рекомендуем разбить код такого SCU на несколько файлов.

SDK имеет одноранговую структуру включения заголовочных файлов (то есть, не `xenolith/scene/actions/XLAction.h`, а просто `XLAction.h`). Это упрощает анализ включений и упрощает отслеживание файлов, включаемых из модуля, который не был подключен. Если следовать правилам именования, заголовочные файлы не будут повторять имени друг друга.

Путь к директории может использоваться для приватных заголовочных файлов модуля, не видимых из других модулей (например, `xenolith/platform/linux/thirdparty/wayland-protocols/xdg-shell-client-protocol.h`).

Для определения заголовочных файлов модуля:

```make
# для определения директорий рекурсивного поиска
MODULE_STAPPLER_DB_INCLUDES_DIRS := $(STAPPLER_MODULE_DIR)/db
# для определения одиночных директорий поиска заголовков
MODULE_STAPPLER_GEOM_INCLUDES_OBJS := $(STAPPLER_MODULE_DIR)/geom $(STAPPLER_MODULE_DIR)/geom/glsl
```

Модуль может определить заголовок для предварительной компиляции. Использование таких заголовков может существенно ускорять компиляцию.

```make
MODULE_XENOLITH_CORE_PRECOMPILED_HEADERS := $(XENOLITH_MODULE_DIR)/core/XLCommon.h
```

Для использования предкомпилированного заголовка, он должен быть включён первой же инструкцией в файле исходного кода (`#include “XLCommon.h”`). В противном случае, будет включён не предкомпилированный, а обычный заголовок. В предкомпилированный заголовок включается максимум общих для модуля заголовков, чтобы обеспечить существенное ускорение компиляции.

При работе с шейдерами GLSL также необходимо указывать директории для заголовочных и исходных файлов:

```make
MODULE_XENOLITH_RENDERER_BASIC2D_SHADERS_SHADERS_DIR := $(XENOLITH_MODULE_DIR)/renderer/basic2d/glsl/shaders
MODULE_XENOLITH_RENDERER_BASIC2D_SHADERS_SHADERS_INCLUDE := $(XENOLITH_MODULE_DIR)/renderer/basic2d/glsl/include
```

Структура директории шейдеров внутри SDK:
* xl_2d_material.frag (директория)
  * main.frag (файл, реализующий точку входа main)
  * main_static.frag (файл, реализующий точку входа static)

Таким образом, SDK позволяет реализовывать шейдеры с несколькими точками входа, которые используются как замена для некоторых платформ.

## Структура исходного кода

### Базовые соглашения

* Для отступов используются табуляции (\t), предполагаемая их длина - 4 символа.
* Пробелы на конце строк (в том числе, пустых строк) не допускаются.
* Общий базовый визуальный стиль кода основан на K&R C.
* Максимальная длина строки - 120 символов.
* Предпочитается агрессивная расстановка пробелов в арифметических операциях
* Использования многострочных комментариев вне заголовков в финальном коде стоит избегать (используйте построчные комментарии из однострочных)
* Инструкции внутри циклов и условий всегда обрамляются фигурными скобками
* Не более одной инструкции с единичным инкрементом или декрементом на строку
* При переносе строк оператор не должен свисать. Вместо этого, следующая строка должна начинаться с оператора
* Квалификаторы задаются в традиционной циклической форме (const String &, а не String const &). Если необходимо больше двух квалификаторов - стоит использовать псевдоним.
* Исключения не используются. Предпочтение отдаётся возврату значения успешности как bool и сохранению внутри данных кода и описания ошибки.
* Объекты должны иметь ошибочное рабочее состояние. То есть. в случае ошибки, вызов функций объекта не должен приводить к падению программы. Вместо этого, все функции такого объекта должны сигнализировать об ошибке.
* Пространства имён
* Весь код SDK для C++ должен быть определён в версионированном пространстве имён stappler.

```cpp
namespace STAPPLER_VERSIONIZED stappler {}
```

* Модули могут определять собственные пространства имён
* Если это имеет логическое значение (crypto, filesystem)
* Если они используют только одну конкретную модель памяти (search)
* В таком случае, в их пространство имён добавляется пространство имён stappler::mem_std или stappler::mem_pool.
* Пространства имён называются в snake_case.

* В SDK предпочтение отдаётся полной декларации пространства имён, вложенности стоит избегать (за исключением деталей реализации)

```cpp
namespace STAPPLER_VERSIONIZED stappler::xenolith::core {}
```

* Платформозависимые функции выделяются в собственное пространство имён `platform` внутри модуля (`stappler::platform`, `stappler::xenolith::platform`).
* Параметры конфигурации модуля выделяются в собственное пространство имён config внутри модуля (`stappler::db::config`, `stappler::xenolith::config`).

### Макросы и параметры конфигурации

Макросы, параметры конфигурации, статические `constexpr` константы и конфигурационные `constexpr` функции записываются прописными буквами с подчеркиваниями. Крайне рекомендуется всегда использовать `constexpr` выражение вместо макроса, когда это возможно.

```cpp
constexpr bool SAFE_BLOCK_ENCODING = true;
constexpr uint32_t XL_MAKE_API_VERSION(uint32_t variant, uint32_t major, uint32_t minor, uint32_t patch);
```

### Классы и структуры

SDK использует различное понимание структур и классов (по некоторой аналогии с Rust).

Имена классов и структур определяются в UpperCamelCase.

#### Общие принципы:

* Статические функции именуются в UpperCamelCase
* Статические поля именуются в UPPER_CASE
* Функции именуются в camelCase и должны начинаться с глагола
* Стандартные имена функций
  * init - функция двухэтапной инициализации, должна возвращать bool
  * invalidate - функция завершения работы объекта и очистки данных. После её вызова объект должен возвращать ошибочное состояние в ответ на любой вызов
* Допускается и приветствуется реализация однострочных невиртуальных функций в описании класса

#### Перечисления (enum):

Перечисления (enum) именуются в UpperCamelCase и значения также именуются в UpperCamelCase. Предпочтение отдается типизированным перечислениям (enum class).

При определении битовых флагов стоит использовать битовые смещения или битовые бинарные определения чисел.

```cpp
enum class InputFlags {
	None,
	TouchMouseInput = 1 << 0,
	KeyboardInput = 1 << 1,
	FocusInput = 1 << 2,
};
SP_DEFINE_ENUM_AS_MASK(InputFlags)

enum Format {
	Json				= 0b0000,
	Pretty			= 0b0001,
	Cbor				= 0b0010,
	DefaultFormat		= 0b0011,
	Serenity			= 0b0100,
	SerenityPretty		= 0b0101,
	PrettyTime			= 0b1001, 
};

```

#### Структуры (struct):

* Фокус на определении укладки данных в памяти
* В первую очередь определяется набор псевдонимов
* Затем, статические функции
* Затем, статические поля
* Затем поля
* Затем функции
* Классификаторы доступа (public, protected, private) не должны использоваться
* Поля именуются в camelCase, однако, предпочтительно их односложное (однословное) название
* Могут реализовывать наследование, но не виртуальные функции.
* Функции установки-получения полей не используются (поля публичны)
* Структуры с именем *Info реализуют информационный заголовок для некоего объекта
* Структуры с именем *Data реализуют хранение данных некоторого объекта

Объединения (union) используют правила для структур.

#### Классы (class):

* Фокус на определении рабочих функций
* Определения вне секций контроля доступа не допускаются
* В первую очередь определяется набор псевдонимов
* Затем, статические функции
* Затем, статические поля
* Затем, определяются public функции (в случае больших классов допустимо разделять публичный интерфейс на логические блоки несколько раз определяя public).
* Затем protected функции и поля
* Затем private функции и поля
* Поля именуются в _prefixedCamelCase и не должны быть в секции public
* Могут реализовывать виртуальные и абстрактные функции
* Функции установки полей начинаются с set. Функции получения полей начинаются с get или is
* Функции обработки событий начинаются с handle (исключение - ряд функций, реализующих логику событий в xenolith: `onContentSizeDirty`, `onTransformDirty`).
* Статические поля, реализующие заголовки событий, именуются в camelCase и начинаются с on (onUpdate, onNetwork).
* Для классов с большим числом полей рекомендуется определить структуру данных типа Data, и использовать её как вложенную в класс.
* Не приветствуется пометка всех функций как виртуальных. Виртуальные функции - только те, что допускают перегрузку.
* Перегруженные функции всегда помечаются как override.
* В случае наличия виртуальных функций в цепочке наследования виртуальный деструктор всегда определяется 

#### Инициализация с именованными переменными.

SDK допускает механизм инициализации с именованными переменными. Это позволяет не следовать порядку переменных при инициализации, вместо этого используя теги имён для полей (с помощью ValueWrapper). Это удобно при большом числе инициализируемых параметров. Такая инициализация допускается в конструкторах и функции init.

Пример реализации:

```cpp
template<typename ... Args>
BufferInfo(Args && ... args) {
	define(std::forward<Args>(args)...);
}


void setup(const BufferInfo &value) { *this = value; }
void setup(BufferFlags value) { flags |= value; }
void setup(ForceBufferFlags value) { flags = value.get(); }
void setup(BufferUsage value) { usage |= value; }
void setup(ForceBufferUsage value) { usage = value.get(); }
void setup(uint64_t value) { size = value; }
void setup(BufferPersistent value) { persistent = value.get(); }
void setup(PassType value) { type = value; }


template <typename T>
void define(T && t) {
	setup(std::forward<T>(t));
}
template <typename T, typename ... Args>
void define(T && t, Args && ... args) {
	define(std::forward<T>(t));
	define(std::forward<Args>(args)...);
}
```

#### Типы, псевдонимы и контейнеры

Типы и их псевдонимы именуются в UpperCamelCase. Также именуются и параметры шаблонов.

Использование контейнеров напрямую из пространств имён `std` или `stappler::memory` нежелательно. наилучший способ - определить псевдонимы контейнеров со стандартными именами (`String`, `Vector`, `Map`) в базовом классе или пространстве имён. Исключение - необходимость использовать типы контейнеров из обоих источников в одном классе, либо выделенно использовать `std` для взаимодействия с внешними интерфейсами.

При передаче неизменных данных и функций для текущего вызова стоит использовать невладеющие контейнеры (`const String &` -> `StringView`, `const Bytes &` -> `BytesView`, `const Function<void()> &` -> `Callback<void()>`). При передаче невладеющих контейнеров в функции не стоит использовать постоянные ссылки (`const StringView &`), поскольку это не приносит пользы (передача таких типов в любом случае займёт два целочисленных регистра или соответствующее место в стеке). Вместо этого, стоит передавать контейнер без квалификаторов.

#### Статические и приватные функции

SDK отдаёт предпочтение статическим функциям внутри модуля компиляции перед функциями в секции private. Также, отдаётся предпочтение отдельной приватной структуре данных вместо описания большого числа полей в классе. Такой подход упрощает поддержку паттернов Copy-on-write и Builder. Детали реализации, которые не важны при использовании структур и классов не должны появляться в их публичных интерфейсах.

Статическая функция, выполняющая роль частной функции класса, именуется как `static Type ClassName_functonName(ClassName::Data &data)`.

Для шаблонов в схожих случаях используется вложенное пространство имён `detail` (в заголовках) либо анонимное пространство имён (в других исходных кодах).

### Рекомендуемые инструментальные проверки

После внесения изменений в код, желательно проверить его с помощью статического и динамического анализаторов.

С позиции статического анализа, как правило, достаточно штатной проверки компиляторами clang и gcc в режиме `-Wall`. После проверки необходимо устранить все предупреждения, либо исправив код на предлагаемый, либо добавив исключение для проверки вокруг проблемного блока кода с пояснением причины отключения проверки.

С позиции динамического анализа, используется проверка с помощью инструмента `memcheck` из пакета `valgrind` и `address sanitizer` из состава компилятора (раздельно). Рекомендуется по возможности устранить все найденные проблемы.

Для подтверждения, что не возникает ошибок, связанных с нестабильной работой потоков, проверку с `address sanitizer` или `valgrind` рекомендуется запустить не менее 10 раз в цикле, перезапуская тестовую программу.

